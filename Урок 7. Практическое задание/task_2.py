from random import random
from timeit import timeit

"""
2. Отсортируйте по возрастанию методом слияния одномерный вещественный массив,
заданный случайными числами на промежутке [0; 50). Выведите на экран исходный
и отсортированный массивы.

Пример:
Введите число элементов: 5
Исходный - [46.11436617832828, 41.62921998361278, 18.45859540989644, 12.128870723745806, 8.025098788570562]
Отсортированный - [8.025098788570562, 12.128870723745806, 18.45859540989644, 41.62921998361278, 46.11436617832828]
"""


def merge_sort(lst_obj):
    l = len(lst_obj)
    if l < 2:
        return lst_obj
    else:
        middle = l // 2
        # рекурсивно разделяем левую часть массива на левую/правую части, которые также разделяются дальше,
        # по принципу дерева, пока не останутся части, представляющие собой массивы из одного элемента
        # (левый массив из одного элемента и правый массив из одного эл-та).
        left = merge_sort(lst_obj[:middle])

        # тоже самое для правой части. Данная рекурсия участвует во всех разделениях левой части, и наоборот.
        right = merge_sort(lst_obj[middle:])

        result = []         # запись результата
        i, j = 0, 0

        # сначала сравнивается самый нижний элемент (дерева) СЛЕВА (левая подветка) с самым нижним элементом СПРАВА
        # в список вносятся элементы по возрастанию, после чего список поднимается на уровень выше и сравнивается
        # со списком, полученным тем же путем, только СПРАВА (правая подветка)
        # (сравнение самого нижнего элемента (дерева) СЛЕВА с самым нижним элементом СПРАВА
        # и внесение в список элементов по возрастанию, после чего список поднимается на уровень выше)
        # далее сравнивается каждый элемент из двух списков и вносится в новый список по возрастанию (слияние списков
        # происходит в новом списке). и так далее, пока не сойдутся самые верхние ветки (верхняя левая и верхняя правая)
        # где также произойдет перебор всех элементов и занесение по возрастанию в окончательный новый список.
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        while i < len(left):
            result.append(left[i])
            i += 1
        while j < len(right):
            result.append(right[j])
            j += 1
        return result


n = int(input('Введите число элементов: '))
lst = [random()*50 for _ in range(n)]

print(f'Исходный - {lst}')
print(f'Отсортированный - {merge_sort(lst)}')

print(f'\nРезультат для {n} элементов: ')
print(timeit("merge_sort(lst)",
             setup="from __main__ import merge_sort, lst", number=1000))



"""
Результаты:
Результат для 10 элементов:
0.026678100000000038
Результат для 100 элементов:
0.4047217999999999
Результат для 1000 элементов:
5.883119400000001
"""

"""
Вывод: Засчет выбора серединного элемента как опорного сложность прохождения цикла
составляет O(log n), но количество циклов зависит от длины массива - N. Получается, скорость выполнения алгоритма 
в итоге составляет O(n log n).
"""