"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы. Сортировка должна быть реализована в
виде функции. Обязательно доработайте алгоритм (сделайте его умнее).

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение
Обязательно сделайте замеры времени обеих реализаций
и обосновать дала ли оптимизация эффективность

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию
"""
from random import randint
from timeit import timeit

numbers = [randint(-100, 100) for _ in range(20)]
print(f'Исходный массив: {numbers}')


def bubble_sort(lst_obj):
    new_obj = lst_obj[:]
    n = 1
    while n < len(new_obj):
        for i in range(len(new_obj) - n):
            if new_obj[i] < new_obj[i + 1]:
                new_obj[i], new_obj[i + 1] = new_obj[i + 1], new_obj[i]
        n += 1
    return new_obj


def bubble_sort_2(lst_obj):
    new_obj = lst_obj[:]
    n = 1
    while n < len(new_obj):
        changes = False
        for i in range(len(new_obj) - n):
            if new_obj[i] < new_obj[i + 1]:
                new_obj[i], new_obj[i + 1] = new_obj[i + 1], new_obj[i]
                changes = True
        if not changes:
            break
        n += 1
    return new_obj


print(f'Отсортированный массив: {bubble_sort(numbers)}')
print(bubble_sort_2(numbers))
print(timeit('bubble_sort(numbers[:])', setup='from __main__ import bubble_sort, numbers', number=10000))
print(timeit('bubble_sort_2(numbers[:])', setup='from __main__ import bubble_sort_2, numbers', number=10000))

sorted_arr = bubble_sort(numbers)

print(timeit('bubble_sort(sorted_arr[:])', setup='from __main__ import bubble_sort, sorted_arr', number=10000))
print(timeit('bubble_sort_2(sorted_arr[:])', setup='from __main__ import bubble_sort_2, sorted_arr', number=10000))

""" Улучшили функцию сортировки. Теперь (как в совете сверху) если за проход по списку не совершается ни одной сортировки,
то происходит завершение.

Проведем замеры на неотсортированном массиве:
Первый запуск:
Исходный массив: [49, 94, 95, 18, -27, -70, 48, -12, 94, 21, -57, 6, 8, 80, 75, 65, 47, 5, -61, 68]
Отсортированный массив: [95, 94, 94, 80, 75, 68, 65, 49, 48, 47, 21, 18, 8, 6, 5, -12, -27, -57, -61, -70]
[95, 94, 94, 80, 75, 68, 65, 49, 48, 47, 21, 18, 8, 6, 5, -12, -27, -57, -61, -70]
0.3170119
0.2994093

Второй запуск:
Исходный массив: [-17, -34, -32, 98, -41, -14, -60, -92, 1, 18, 80, -15, 75, -74, -97, -43, -59, -36, 38, -71]
Отсортированный массив: [98, 80, 75, 38, 18, 1, -14, -15, -17, -32, -34, -36, -41, -43, -59, -60, -71, -74, -92, -97]
[98, 80, 75, 38, 18, 1, -14, -15, -17, -32, -34, -36, -41, -43, -59, -60, -71, -74, -92, -97]
0.3387395
0.33450290000000005

Третий запуск:
Исходный массив: [95, -56, 34, 66, -37, 15, 50, -20, -80, -57, -79, -89, 12, 50, -4, -22, -24, -23, 73, 25]
Отсортированный массив: [95, 73, 66, 50, 50, 34, 25, 15, 12, -4, -20, -22, -23, -24, -37, -56, -57, -79, -80, -89]
[95, 73, 66, 50, 50, 34, 25, 15, 12, -4, -20, -22, -23, -24, -37, -56, -57, -79, -80, -89]
0.3503615
0.39137109999999997

При сортировке отсортированного массива первоначальная функция дала результат: 0.23076330000000012,
а улучшенная 0.02008450000000006

Вывод: при сортировке рандомного массива замеры почти одинаковые, а в каких-то случаях модернизированная функция показы-
вает худший результат. Но при сортировке уже отсортированного массива модернизированная функция работает примерно в 10 раз быстрее.
Отсюда можно сделать вывод, что такая модернизация имеет место быть, если есть вероятость, что массив уже отсортирован. 
В нашем случае, где массив состоит из рандомных чисел, такая модернизация не эффективна.

"""
