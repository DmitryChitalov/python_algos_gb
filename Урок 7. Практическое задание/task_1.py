"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы. Сортировка должна быть реализована в
виде функции. Обязательно доработайте алгоритм (сделайте его умнее).

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение
Обязательно сделайте замеры времени обеих реализаций
и обосновать дала ли оптимизация эффективность

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию
"""

import random
from timeit import timeit

def make_lst(n, dw = -100, up = 100):
    """
    Возвращает список длинной n, заполненный случайными целыми числами 
    в диапазоне от [-100; 100]

    """
    return [random.randint(dw,up) for i in range(n)]


def common_bubble(lst):
    """
    Возвращает отсортированный по убыванию список методом пузырьковой сортировки

    """
    ls = lst.copy() # копируем чтобы не затереть исходный список
    n = 1
    while n < len(ls):
        for i in range(len(ls)-n):
            if ls[i] < ls[i+1]:
                ls[i], ls[i+1] = ls[i+1], ls[i]
        n +=1

    return ls

def smart_bubble(lst):
    """
    Возвращает отсортированный по убыванию список методом пузырьковой сортировки
    Обрабатывает случай если элементы в списке уже упорядочены должным образом

    """
    ls = lst.copy() # копируем чтобы не затереть исходный список
    ex_flag = True # флаг - если не выполнено ни одной перестановки не сортируем список

    n = 1 

    while n < len(ls):
        for i in range(len(ls)-n):
            if ls[i] < ls[i+1]:
                ls[i], ls[i+1] = ls[i+1], ls[i]
                ex_flag = False
        if ex_flag : # если на первом переборе не было перестановок - список отсортирован
            return ls # список уже упорядочен
        n += 1
    return ls


# Проверяем правильность работы и делаем замеры времени


sample_10 = make_lst(10)
sample_100 = make_lst(100)
sample_1000 = make_lst(1000)

if __name__ == '__main__':

    print('Исходный список:', sample_10)
    print('Время выполнения обычная сортировка ',
       timeit("print('Отсортированный список: ',common_bubble(sample_10, ))", 
       "from __main__ import common_bubble, sample_10",
       number = 1))

    print("Исходный список: ", sample_10)
    print('Время выполнения улучшенная сортировка ',
       timeit("print('Отсортированный список: ',smart_bubble(sample_10, ))",
        "from __main__ import smart_bubble, sample_10",
       number=1))

# На 100 элементов
    print('Размер иссходного списка:', len(sample_100))
    print('Время выполнения обычная сортировка ',
       timeit("common_bubble(sample_100, )", 
       "from __main__ import common_bubble, sample_100",
       number = 1))

    print('Время выполнения улучшенная сортировка ',
       timeit("smart_bubble(sample_100, )",
        "from __main__ import smart_bubble, sample_100",
       number=1))

# На 1000 элементов
    print('Размер иссходного списка:', len(sample_1000))
    print('Время выполнения обычная сортировка ',
       timeit("common_bubble(sample_1000, )", 
       "from __main__ import common_bubble, sample_1000",
       number = 1))

    print('Время выполнения улучшенная сортировка ',
       timeit("smart_bubble(sample_1000, )",
        "from __main__ import smart_bubble, sample_1000",
       number=1))

"""
Вывод программы:
python3 'Урок 7. Практическое задание/task_1.py'
Исходный список: [3, -89, -42, 41, 73, 58, 24, 58, -80, 47]
Отсортированный список:  [73, 58, 58, 47, 41, 24, 3, -42, -80, -89]
Время выполнения обычная сортировка  7.658800313947722e-05
Исходный список:  [3, -89, -42, 41, 73, 58, 24, 58, -80, 47]
Отсортированный список:  [73, 58, 58, 47, 41, 24, 3, -42, -80, -89]
Время выполнения улучшенная сортировка  5.370299913920462e-05
Размер иссходного списка: 100
Время выполнения обычная сортировка  0.002266043004055973
Время выполнения улучшенная сортировка  0.002390178997302428
Размер иссходного списка: 1000
Время выполнения обычная сортировка  0.4110498039954109
Время выполнения улучшенная сортировка  0.39147043399862014

Замеры показывают, что улучшенный метод работает заметно быстрее. Хотя в свою очередь, случайная генерация заранее упорядоченного списка должна быть довольно редким явлением. Возможно "под капотом" работает еще какой-то оптимизатор выделения памяти, сохраняющий одинаковые значения.

"""