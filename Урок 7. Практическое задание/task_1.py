"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы. Сортировка должна быть реализована в
виде функции. Обязательно доработайте алгоритм (сделайте его умнее).

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение
Обязательно сделайте замеры времени обеих реализаций
и обосновать дала ли оптимизация эффективность

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию
"""


from random import randint
from time import time


def time_func(f):
    def wrapper(*args, **kwargs):
        st = time()
        res = f(*args, **kwargs)
        print(time() - st)
        return res

    return wrapper


@time_func
def bubble(arr):
    l = len(arr)
    for i in range(l):
        for j in range(l - i - 1):
            if arr[j] < arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

    return arr


@time_func
def bubble_smart(arr):
    l = len(arr)
    for i in range(l):
        exch = False
        for j in range(l - i - 1):
            if arr[j] < arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                exch = True
        if not exch:
            break
    return arr


a = [randint(0, 1000) for i in range(10000)]
print(a)
print(bubble(a[:]))
print(bubble_smart(a[:]))
print(bubble_smart(sorted(a[:], reverse=True)))
print(bubble_smart(sorted(a[:])))

"""
Классический пузырек          - 10.884214401245117   10.64104318618774
Оптимизированный пузырек      - 10.180044412612915   11.34058666229248
Уже отсортированный список    -  0.001100540161133    0.00106239318848
Отсортрованный по возрастанию - 14.88435959815979    14.29628562927246
Результаты интересные. 
На рандомном списке время работы оптимизированного алгоритма плавает около значения неоптимизированного алгоритма, 
причем разброс в обе стороны.
Проверил на крайних вариантах, т.е. когда список уже отсортирован в нужном порядке (ничего делать не надо) и 
противоположном (самый худший вариант).
Оптимизация дает тем больший эффект, чем более отсортирован список, подаваемый на сортировку.
Оптимизированный вариант с одной стороны исключает холостые прогоны циклов, когда уже всё отсортировано, 
но с другой стороны есть накладные расходы на работу с дополнительной переменной - присваивание, проверка значения.
"""

