"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы. Сортировка должна быть реализована в
виде функции. Обязательно доработайте алгоритм (сделайте его умнее).

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение
Обязательно сделайте замеры времени обеих реализаций
и обосновать дала ли оптимизация эффективность

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию
"""
from timeit import timeit
import random


def bubble_sort_1(lst):  # Классическая сортировка пузырьком
    for passnum in range(len(lst) - 1, 0, -1):
        for i in range(passnum):
            if lst[i] < lst[i + 1]:
                temp = lst[i]
                lst[i] = lst[i + 1]
                lst[i + 1] = temp
    return lst


def short_bubble_sort(lst):  # Короткая сортировка пузырьком
    exchanges = True
    passnum = len(lst) - 1
    while passnum > 0 and exchanges:
        exchanges = False
        for i in range(passnum):
            if lst[i] < lst[i + 1]:
                exchanges = True
                temp = lst[i]
                lst[i] = lst[i + 1]
                lst[i + 1] = temp
        passnum = passnum - 1
    return lst


array = [random.randint(-100, 100) for _ in range(100)]

print(f"Исходный массив {array}")

bubble_sort_1(array)
short_bubble_sort(array)


print(f'Классическая пузырьковая сортировка: {bubble_sort_1(array)} ')
print(timeit(
             'bubble_sort_1(array[:])',
             setup='from __main__ import bubble_sort_1, array', number=1000))

print(f'Короткая пузырьковая сортировка: {short_bubble_sort(array)} ')
print(timeit(
            'short_bubble_sort(array[:])',
            setup='from __main__ import short_bubble_sort, array', number=1000))

'''
Классическая пузырьковая сортировка делает проход по всей несортированной части списка

Короткая пузырьковая сортировка отличается.
Если во время прохода не было сделано ни одной перестановки, 
то мы знаем, что список уже отсортирован. Таким образом, алгоритм может быть модифицирован, 
чтобы останавливаться раньше, если обнаруживает, что задача выполнена. 

Вариант короткой пузырьковой сортировки подсмотрел в одном из учебников по python.


Исходный массив [95, -91, 13, 2, -69, -5, 41, -84, -77, -97, -59, -29, -60, 86, -24, -20, 35, 95, -38, 13, 70, -14, -100, -75, 51, -85, 90, 83, 100, 23, 0, 95, -57, -16, -11, 77, -43, 33, 75, 52, 20, 81, 90, 66, 54, -65, 32, -39, -96, 14, 29, -83, -92, -46, 11, 55, -25, -24, 19, 52, 58, -20, -73, 60, 96, 14, -95, 0, 83, -79, 74, -15, -80, -25, 69, 77, -84, -35, -74, 22, -100, 2, -21, 43, 39, 100, -7, -97, -24, -60, -70, -26, 92, 27, -65, -23, -69, -88, -24, -92]
Классическая пузырьковая сортировка: [100, 100, 96, 95, 95, 95, 92, 90, 90, 86, 83, 83, 81, 77, 77, 75, 74, 70, 69, 66, 60, 58, 55, 54, 52, 52, 51, 43, 41, 39, 35, 33, 32, 29, 27, 23, 22, 20, 19, 14, 14, 13, 13, 11, 2, 2, 0, 0, -5, -7, -11, -14, -15, -16, -20, -20, -21, -23, -24, -24, -24, -24, -25, -25, -26, -29, -35, -38, -39, -43, -46, -57, -59, -60, -60, -65, -65, -69, -69, -70, -73, -74, -75, -77, -79, -80, -83, -84, -84, -85, -88, -91, -92, -92, -95, -96, -97, -97, -100, -100] 
0.8345559
Короткая пузырьковая сортировка: [100, 100, 96, 95, 95, 95, 92, 90, 90, 86, 83, 83, 81, 77, 77, 75, 74, 70, 69, 66, 60, 58, 55, 54, 52, 52, 51, 43, 41, 39, 35, 33, 32, 29, 27, 23, 22, 20, 19, 14, 14, 13, 13, 11, 2, 2, 0, 0, -5, -7, -11, -14, -15, -16, -20, -20, -21, -23, -24, -24, -24, -24, -25, -25, -26, -29, -35, -38, -39, -43, -46, -57, -59, -60, -60, -65, -65, -69, -69, -70, -73, -74, -75, -77, -79, -80, -83, -84, -84, -85, -88, -91, -92, -92, -95, -96, -97, -97, -100, -100] 
0.016855300000000017


'''