"""
Задание 4.

Приведены два алгоритма. В них определяется число,
которое встречается в массиве чаще всего.

Сделайте профилировку каждого алгоритма через timeit

Попытайтесь написать третью версию, которая будет самой быстрой.
Сделайте замеры и опишите, получилось ли у вас ускорить задачу.
"""
from timeit import default_timer
from collections import Counter

# тестовые массивы чисел
array_1 = [1, 3, 1, 3, 4, 5, 1]

array_2 = [1, 3, 1, 3, 4, 5, 1, 1, 3, 1, 3, 4, 5, 1, 1, 3, 1, 3, 4, 5, 1, 1, 3, 1, 3, 4, 5, 1]

array_3 = [1, 3, 1, 3, 4, 5, 1, 1, 3, 1, 3, 4, 5, 1, 1, 3, 1, 3, 4, 5, 1, 1, 3, 1, 3, 4, 5, 1,
           1, 3, 1, 3, 4, 5, 1, 1, 3, 1, 3, 4, 5, 1, 1, 3, 1, 3, 4, 5, 1, 1, 3, 1, 3, 4, 5, 1]

NUMBER = 100000  # число запусков


# декоратор для подсчёта времени выполнения
def timer(num=1000000):
    def time_dec(func):
        def wrapper(*args):
            result_time = 0
            result = None
            for _ in range(num):
                start = default_timer()
                result = func(*args)
                delta_time = default_timer() - start
                result_time += delta_time
            print(f'Общее время:{result_time}')
            return result
        return wrapper
    return time_dec


@timer(NUMBER)
def func_1(array):  # O(N^2)
    m = 0
    num = 0
    for i in array:
        count = array.count(i)
        if count > m:
            m = count
            num = i
    return f'Чаще всего встречается число {num}, ' \
           f'оно появилось в массиве {m} раз(а)'


@timer(NUMBER)
def func_2(array):   # O(N^2)
    new_array = []
    for el in array:
        count2 = array.count(el)
        new_array.append(count2)

    max_2 = max(new_array)
    elem = array[new_array.index(max_2)]
    return f'Чаще всего встречается число {elem}, ' \
           f'оно появилось в массиве {max_2} раз(а)'


# функция без метода count (что уменьшило её сложность до линейной)
@timer(NUMBER)
def func_3(array):    # O(N)
    result = dict()
    for element in array:
        if element not in result:
            result[element] = 0
        result[element] += 1
    max_elem = max(result, key=lambda x: result[x])
    return f'Чаще всего встречается число {max_elem}, ' \
           f'оно появилось в массиве {result[max_elem]} раз(а)'


# немножко готового функционала:
@timer(NUMBER)
def func_4(array):    # O(N)
    result = Counter(array)
    max_elem = max(result, key=lambda x: result[x])
    return f'Чаще всего встречается число {max_elem}, ' \
           f'оно появилось в массиве {result[max_elem]} раз(а)'


print('\nЗамеры для func_1:')
for arr in (array_1, array_2, array_3):
    res = func_1(arr)
    print(res)

print('\nЗамеры для func_2:')
for arr in (array_1, array_2, array_3):
    res = func_2(arr)
    print(res)

print('\nЗамеры для func_3:')
for arr in (array_1, array_2, array_3):
    res = func_3(arr)
    print(res)

print('\nЗамеры для func_4:')
for arr in (array_1, array_2, array_3):
    res = func_4(arr)
    print(res)

# Первые две функции имеют квадратичную сложность, так как используют метод count -
# то есть для каждого элемента выполняется проход по всему массиву, чтобы подсчитать количество вхождений.
# Такая сложность алгоритмов наводит на мысль, что при большом количестве элементов оба они будут совершенно
# не оптимальны по времени выполнения. Первый алгоритм работает чуть быстрее за счёт отсутствия дополнительных
# операций с массивом. Замеры только подтверждают, что при увеличении размера массива скорость выполнения
# первого и второго алгоритмов резко снижается. Именно поэтому метод count рекомендуется использовать только на списках
# # с малым числом элементов или для поиска количества вхождений в список одного элемента.
# Третья функция имеет линейную сложность выполнения - проход по массиву для подсчёта происходит всего один раз
# и для определения максимума используется встроенная функция max, так же имеющая линейную сложность.
# При тестировании на малом количестве элементов создаётся впечатление, что третья функция работает медленнее первых
# двух. Однако с ростом числа элементов становится понятно, что скорость выполнения третьей функции снижается
# гораздо медленнее, чем у первой и второй.
# Четвёртая функция реализована через класс Counter модуля Collections, и этот класс как раз и предназначен для
# подсчёта количества вхождений каждого элемента в массив. На большом количестве элементов она будет самой быстрой.
