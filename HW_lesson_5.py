"""
1.	Пользователь вводит данные о количестве предприятий, их наименования и прибыль
за 4 квартала (т.е. 4 отдельных числа) для каждого предприятия.
Программа должна определить среднюю прибыль (за год для всех предприятий)
и вывести наименования предприятий, чья прибыль выше среднего и отдельно
вывести наименования предприятий, чья прибыль ниже среднего.

Подсказка:
Для решения задачи обязательно примените какую-нибудь коллекцию из модуля collections
Для лучшее освоения материала можете даже сделать несколько решений этого задания,
применив несколько коллекций из модуля collections

Пример:
Введите количество предприятий для расчета прибыли: 2
Введите название предприятия: Рога
через пробел введите прибыль данного предприятия
за каждый квартал(Всего 4 квартала): 235 345634 55 235

Введите название предприятия: Копыта
через пробел введите прибыль данного предприятия
за каждый квартал(Всего 4 квартала): 345 34 543 34

Средняя годовая прибыль всех предприятий: 173557.5
Предприятия, с прибылью выше среднего значения: Рога

Предприятия, с прибылью ниже среднего значения: Копыта
"""

import collections
from collections import namedtuple, deque
from timeit import timeit

company_lst = []

try:
    average_income = 0
    num = int(input('Введите количество предприятий для расчета прибыли: '))

    for i in range(num):
        name = input('Введите название предприятия: ')
        profit = list(map(int, input('через пробел введите прибыль данного предприятия за каждый квартал (Всего 4 '
                                     'квартала): ').split()))
        profit = int(sum(profit))
        Company = namedtuple('Предприятие', 'Имя Прибыль')
        company_lst.append(Company(name, profit))

    print(company_lst)

    average_income = sum(Company.Прибыль for Company in company_lst)
    average_income = average_income / len(company_lst)
    print(f'Средняя годовая прибыль всех предприятий: {average_income}')

    above = []
    [above.append(Company.Имя) for Company in company_lst if Company.Прибыль > average_income]
    print(f'Наименования предприятий, чья прибыль выше среднего: {above}')

    below = []
    [below.append(Company.Имя) for Company in company_lst if Company.Прибыль < average_income]
    print(f'Наименования предприятий, чья прибыль ниже среднего: {below}')

except ValueError:
    print('Вы ввели не число.')

# ---------------------------------------------- 2 ----------------------------------------------

"""
Задача 3.
В соответствии с документацией Python,
deque – это обобщение стеков и очередей.
Вот основное правило: если вам нужно что-то быстро дописать или вытащить, используйте deque.
Если вам нужен быстрый случайный доступ, используйте list.

Задача: создайте простой список (list) и очередь (deque).
Выполните различные операции с каждым из объектов.
Сделайте замеры и оцените, насколько информация в документации
соответствует дейстивтельности.
"""

my_list = list(range(1, 100))

simple_lst = list(range(1, 100))
deq_obj = deque(simple_lst)

time1 = timeit("deq_obj.append('100')", setup="from __main__ import deq_obj", number=10000)
time2 = timeit("my_list.append('100')", setup="from __main__ import my_list", number=10000)
time3 = timeit("deq_obj.appendleft('0')", setup="from __main__ import deq_obj", number=10000)
time4 = timeit("my_list.insert(0, '0')", setup="from __main__ import my_list", number=10000)
time5 = timeit("deq_obj.pop()", setup="from __main__ import deq_obj", number=10000)
time6 = timeit("my_list.pop()", setup="from __main__ import my_list", number=10000)
time7 = timeit("deq_obj.popleft()", setup="from __main__ import deq_obj", number=10000)
time8 = timeit("del my_list[0]", setup="from __main__ import my_list", number=10000)

print('\n', 10*'-', ' Задача №3 ', 10*'-', '\n')

print(f'Время добавления элементов в конец очереди: {time1}')
print(f'Время добавления элементов в конец списка: {time2}')
print()
print(f'Время добавления элементов в начало очереди: {time3}')
print(f'Время добавления элементов в начало списка: {time4}')
print()
print(f'Время удаления элементов с конца очереди: {time5}')
print(f'Время удаления элементов с конца списка: {time6}')
print()
print(f'Время удаления элементов с начала очереди: {time7}')
print(f'Время даления элементов с начала списка: {time8}')

"""
Результаты программы:

Время добавления элементов в конец очереди: 0.0008175999999999947
Время добавления элементов в конец списка: 0.0010386000000000006

Время добавления элементов в начало очереди: 0.0008488000000000037
Время добавления элементов в начало списка: 0.08161679999999999

Время удаления элементов с конца очереди: 0.0009147999999999934
Время удаления элементов с конца списка: 0.0009608999999999868

Время удаления элементов с начала очереди: 0.0007396000000000069
Время даления элементов с начала списка: 0.026474600000000015


Вывод: документация Python не обманывает, deque при удалении и добавлении элементов справляется быстрее, чем list.
"""

# ---------------------------------------------- 3 ----------------------------------------------

"""
Задача 4.
Поработайте с обычным словарем и OrderedDict.
Выполните различные операции с каждым из объектов и сделайте замеры.
Опишите полученные результаты, сделайте выводы.
"""


def func_with_dict():  # Заполнение словаря dict (простой словарь)
    d = dict()
    for i in range(1, 1000):
        name = f'key_{i}'
        d[name] = i
    return d


def func_with_ordereddict():  # Заполнение словаря OrderedDict
    d = collections.OrderedDict()  # Словарь с памятью порядка добавления элементов
    for i in range(1, 1000):
        name = f'key_{i}'
        d[name] = i
    return d


def cycle_dict():  # Перебор пар простого словаря и сохранение в новом простом словаре
    d = func_with_dict()  # только четных ключей и их значений
    new_d = dict()
    for key, value in d.items():
        if int(key[-1]) % 2 == 0:
            new_d[key] = value * 2
    return new_d


def cycle_ordereddict():  # Перебор пар словаря OrderedDict и сохранение в новом словаре OrderedDict
    d = func_with_ordereddict()  # только четных ключей и их значений
    new_d = collections.OrderedDict()
    for key, value in d.items():
        if int(key[-1]) % 2 == 0:
            new_d[key] = value * 2
    return new_d


time_1 = timeit('func_with_dict()', setup='from __main__ import func_with_dict', number=1000)
time_2 = timeit('func_with_ordereddict()', setup='from __main__ import func_with_ordereddict', number=1000)
time_3 = timeit('cycle_dict()', setup='from __main__ import cycle_dict', number=1000)
time_4 = timeit('cycle_ordereddict()', setup='from __main__ import cycle_ordereddict', number=1000)

print('\n', 10*'-', ' Задача №4 ', 10*'-', '\n')

print(f'Заполненный список dict (простой словарь):\n {func_with_dict()}')
print(f'Заполненный список OrderedDict:\n {func_with_ordereddict()}')

print('\nВремя заполнения пустого dict ключами со значениями: {:.2f}'.format(time_1))
print('Время заполнения пустого OrderedDict ключами со значениями: {:.2f}'.format(time_2))

print('\nВремя заполнения и перебора пар из dict, а также добавление только \n'
      'четных ключей со значениями в новый словарь dict (new_d): {:.2f}'.format(time_3))
print('\nВремя заполнения и перебора пар из OrderedDict, а также добавление только \n'
      'четных ключей со значениями в новый словарь OrderedDict (new_d): {:.2f}'.format(time_4))

"""
Результаты программы:

Время заполнения пустого dict ключами со значениями: 0.55
Время заполнения пустого OrderedDict ключами со значениями: 0.64

Время заполнения и перебора пар из dict, а также добавление только 
четных ключей со значениями в новый словарь dict (new_d): 1.09

Время заполнения и перебора пар из OrderedDict, а также добавление только 
четных ключей со значениями в новый словарь OrderedDict (new_d): 1.30


Выводы: Заполнение и перебор пар в простом словаре (dict) занимает немного меньше времени, чем аналогичные операции со 
словарем OrderedDict. К тому же, при выводе двух параллельно созданных словарей видно, что оба словаря имеют память 
порядка добавления элементов. Поэтому использование OrderedDict перестает быть необходимым.
"""
# --------------------------------------------------------------------------------------------
