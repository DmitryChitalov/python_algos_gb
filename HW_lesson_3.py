"""
Задание 1.

Докажите, что словари обрабатываются быстрее, чем списки.

Реализуйте две функции, в первой нужно заполнить элементами список, во второй-словарь
Сделайте замеры времени выполнения каждой из функций

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к двум своим функциям.
"""

import random
import time
from uuid import uuid4
import hashlib


def f_list(count):
    start = time.time()
    my_list = []
    for _ in range(count):
        my_list.append(random.randint(0, 1000))
    end = time.time()
    t = end - start
    return t


def f_dict(count):
    start = time.time()
    my_dict = {}
    for i in range(count):
        my_dict[i] = random.randint(0, 1000)
    end = time.time()
    t = end - start
    return t


print('--------------------- 1 ----------------------------')
print(f'Заполнение списка заняло {f_list(1000000)} секунд')
print(f'Заполнение словаря заняло {f_dict(1000000)} секунд')

"""
Задание 2.
Ваша программа должна запрашивать пароль
Для этого пароля вам нужно получить хеш, используя функцию sha256
Для генерации хеша обязательно нужно использовать криптографическую соль
Обязательно выведите созданный хеш

Далее программа должна запросить пароль повторно
Вам нужно проверить, совпадает ли пароль с исходным
Для проверки необходимо сравнить хеши паролей

ПРИМЕР:
Введите пароль: 123
В базе данных хранится строка: 555a3581d37993843efd4eba1921f1dcaeeafeb855965535d77c55782349444b
Введите пароль еще раз для проверки: 123
Вы ввели правильный пароль
"""

print('--------------------- 2 ----------------------------')
password = input('Введите пароль: ')
salt = uuid4().hex
res = hashlib.sha256(salt.encode() + password.encode()).hexdigest()
print('В базе данных хранится строка:', res)
password = input('Введите пароль еще раз для проверки: ')
if hashlib.sha256(salt.encode() + password.encode()).hexdigest() == res:
    print('Пароль верный.')
else:
    print('Пароль неверный.')

"""
Задание 3.
Определить количество различных подстрок с использованием хеш-функции.
Дана строка S длиной N, состоящая только из строчных латинских букв.

Подсказка: примените хеши и множества

рара:

рар
ра
ар
ара
р
а
"""

print('--------------------- 3 ----------------------------')

line = 'papa'
res = set()

n = len(line)
for i in range(n):
    if i == 0:
        n = len(line) - 1
    else:
        n = len(line)
    for j in range(n, i, -1):
        print(line[i:j])
        res.add(hashlib.md5(line[i:j].encode('utf-8')).hexdigest())
print(res)

print("Количество разных подстрок =", len(res))

"""
Задача 4.
Реализуйте скрипт "Кеширование веб-страниц"

Функция должна принимать url-адрес и проверять
есть ли в кэше соответствующая страница, если нет, то вносит ее в кэш

Подсказка: задачу решите обязательно с применением 'соленого' хеширования
Можете условжнить задачу, реализовав ее через ООП
"""

print('--------------------- 4 ----------------------------')


def f_cache(in_url, in_cache_url):
    sal = 'url'
    if (hashlib.sha256(sal.encode() + in_url.encode()).hexdigest()) in in_cache_url:
        print('Данная страница уже есть в кэше. Введите другой url-адрес.')
        print()
    else:
        in_cache_url.add(hashlib.sha256(sal.encode() + in_url.encode()).hexdigest())
        print('Страница внесена в кэш.')
    return in_cache_url


cache_url = set()  # кэш, где будут храниться url-адреса

while True:
    print()
    url = input('Введите url-адрес, для отмены введите 0: ')
    if url == '0':
        print('Программа завершена')
        break
    else:
        print('Кэш:\n', f_cache(url, cache_url))
