"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""

companies_dict = {
    'Рога и копыта': 10988.00,
    'Кошкин дом': 5000.00,
    'Окошки': 84675.00,
    'Гордый Пингвин': 79000.00,
    'Яблоко': 100000.00
}


def sort_by_profit_1(data: dict, num: int) -> list:
    """
    Функция возвращает указанное в параметре num количество фирм с наибольшим средним доходом
    :param data: словарь с данными по фирмам
    :param num: количество возвращаемых элементов
    :return: список кортежей
    Сложность: O(N logN) - линейно-логарифмическая
    """
    result_list = list(data)  # O(N)
    result_list.sort(key=lambda x: data[x], reverse=True)  # O(N logN)
    return [(key, data[key]) for key in result_list[:num]]  # O(N)


print(sort_by_profit_1(companies_dict, 3))


def sort_by_profit_2(data: dict) -> list:
    """
    Функция возвращает три фирмы с наибольшим средним доходом
    :param data: словарь с данными по фирмам
    :return: список кортежей
    Сложность: линейная
    """
    result = []  # O(1)
    key_list = list(data)  # O(N)
    for _ in range(3):  # O(3)
        max_item = max(key_list, key=lambda x: data[x])  # O(N)
        result.append((max_item, data[max_item]))  # O(N)
        key_list.remove(max_item)  # O(1)
    return result  # O(1)


print(sort_by_profit_2(companies_dict))

# Выводы: первая функция выглядит лаконичнее, но примененение в ней метода sort поднимает
# сложность алгоритма до линейно-логарифмической. С другой стороны, сколько бы элементов не потребовалось отобрать
# (если их будет не три, а больше), эта функция останется на прежнем уровне сложности.
# Вторая функция возвращает строго три элемента и за счёт этого её сложность определяется сложностью реализации функции
# max и метода append, то есть будет линейной. При данных условиях задачи эта функция предпочтительнее первой,
# но стоит только сделать количество возвращаемых элементов изменяемым параметром, и её сложность станет квадратичной,
# что в перспективе делает её худшим вариантом.
