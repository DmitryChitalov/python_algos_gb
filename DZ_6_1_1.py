"""
Задание 1.

Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

дПримечание: Для анализа возьмите любые 1-5 ваших разных скриптов!.
Селать их разные реализации.

Можно взять задачи с курса Основ
или с текущего курса Алгоритмов

Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""
import timeit
from memory_profiler import profile
from sys import getrefcount
from random import randint


@profile
def func_gen():
    a = [randint(1, 100) for _ in range(300000)]
    res = [a[i] for i in range(1, len(a)) if a[i - 1] < a[i]]
    print(getrefcount(a))
    del a
    print(getrefcount(res))
    return res


@profile
def func_app():
    b = [randint(1, 100) for _ in range(300000)]
    i = 0
    new_list = []
    while i < len(b):
        if b[i - 1] < b[i]:
            new_list.append(b[i])
        i += 1
    print(getrefcount(b))
    del b
    print(getrefcount(new_list))
    return new_list


elapsed_func_gen = (timeit.timeit("func_gen()",
                                  setup="from __main__ import func_gen",
                                  number=1))
elapsed_func_app = (timeit.timeit("func_app()",
                                  setup="from __main__ import func_app",
                                  number=1))
print(elapsed_func_gen)
print(elapsed_func_app)

# В основах python была задача, дан массив чисел и надо было найти число которое больше предыдущего числа из массива,
# в данном варианте решение через генератор гораздо быстрее и менее затратно в точки зрения потребления ресурсов,
# в варианте с генератором число вхождений два раза по 300 тыс. Происходит увеличение исп. памяти с 16.3 до 18.9
# После того как я удалил переменную а, сразу же память очистилась на 1.2 MiB. Во втором варианте с циклом while все
# гораздо хуже - число вхождений аж 4 раза по 300 тыс. То есть тратися в 2 раза больше времени на обработку большого
# массива данных, но исп. памяти примерно одинаковое, в этом же варианте видим как удаление не используемой
# переменной освобождается память.
