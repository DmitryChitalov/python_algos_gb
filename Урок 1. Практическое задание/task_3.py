"""
Задание 3.

Для этой задачи:
1) придумайте 1-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.


Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""
from random import randint, seed


# O(nlogn)
def method1(s):
    stor_list = list(s.items())         # O(n)
    stor_list.sort(key=lambda i: i[1])  # O(nlogn)
    print(f'1 - {stor_list[-1]}', f'2 - {stor_list[-2]}', f'3 - {stor_list[-3]}', sep=',\n')


# O(n^2)
def method2(s):
    for i in range(len(s)):                 # O(n)
        max_i = i
        for j in range(i+1, len(s)):        # O(n)
            if s[j][1] > s[max_i][1]:
                max_i = j
        s[i], s[max_i] = s[max_i], s[i]
    print(f'{s[0:3]}')


# O(n) или O(3n) поскольку max запускается в цикле 3 раза
def method3(s):
    sorted_s = {}
    copy_s = dict(s)
    for i in range(3):          # O(n)
        max_in_s = max(copy_s.items(), key=lambda s_i: s_i[1])          # O(n)
        sorted_s[max_in_s[0]] = copy_s.pop(max_in_s[0])                 # O(1)
    print(sorted_s)


stor = {"K1": 0, "K2": 0, "K3": 0, "K4": 0, "K5": 0, "K6": 0, "K7": 0, "K8": 0, "K9": 0, "K10": 0}
seed()
for k in stor.keys():
    stor[k] = randint(0, 1000000)
print(stor)
method1(stor)
method2(list(stor.items()))
method3(stor)

# самый эффективный способ - 3й (method3). Его сложность линейная  - O(n)
