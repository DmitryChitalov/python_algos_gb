"""
Задание 3.

Для этой задачи:
1) придумайте 1-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.


Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""

companies = {"Система" : 81745,
            "Аэрофлот" : 124211,
            "АЛРОСА" : 736791,
            "МКБ" : 139461,
            "СевСт" : 819289,
            "ДетскийМир" : 68668,
            "ФСК ЕЭС" : 200020,
            "FIVE" : 473216,
            "ГАЗПРОМ" : 3915599,
            "ГМКНорНик" : 2028232,
            "РусГидро" : 216469,
            "ИнтерРАО" : 427048,
            "ЛУКОЙЛ" : 4336597,
            "ММК" : 515137,
            "Магнит" : 356690,
            "МосБиржа" : 204944,
            "Мечел" : 496997,
            "МТС" : 967547}


def first_sol(obj_dict):
    """
    Итоговая сложность данной функции O(n^3) так как мы имеем 3 вложенных цикла:
    каждой итерации while - проход по словарю (for i in dict), а так же постоянный поиск max() при каждом проходе.
    """
    result = []                                         # O(1)
    raw_dict = obj_dict.copy()                          # O(n)
    while len(result) != 3:                             # O(n)
        for i in raw_dict:                              # O(n)
            if max(raw_dict.values()) == raw_dict[i]:   # max - O(n) и O(1) в итоге O(n)
                result.append(f"{i} - {raw_dict[i]}")   # O(1)
                max_id = i                              # O(1)
        raw_dict.pop(max_id)                            # O(1)
    return result                                       # O(1)


def second_sol(obj_dict, result=[]):
    """
    Итоговая сложность данной рекурсивной функции по моему мнению это O(n^2).
    У нас отсуствуют вложенные циклы в теле самой функции, но есть два последовательных
    цикла при каждом вызове: max() и проход по словарю для поиска. Но так как сама по себе рекурсия
    это своего рода цикл, то в итоге по моим подсчетам получается - O(n^2).
    """
    raw_dict = obj_dict.copy()                      # O(n)
    if len(result) == 3:                            # O(1)
        return result                               # O(1)
    max_val = max(raw_dict.values())                # O(n)
    for i in raw_dict:                              # O(n)
        if max_val == raw_dict[i]:                  # O(1)
            result.append(f"{i} - {raw_dict[i]}")   # O(1)
            raw_dict.pop(i)                         # O(1)
            return second_sol(raw_dict, result)     # O(1)


def third_sol(obj_dict):
    """
    Итоговая сложность данной функции O(n log n), тут отсуствуют вложенные циклы, но зато имеется сортировка
    словаря по значению и её сложность является максимальной.
    """
    result = []                                                                 # O(1)
    for i in sorted(obj_dict.items(), key=lambda item: item[1], reverse=True):  # O(n log n)
        result.append(f"{i[0]} - {i[1]}")                                       # O(1)
        if len(result) == 3:                                                    # O(1)
            return result                                                       # O(1)


"""
В итоге алгоритмы расположены по увеличению эффективности и самой эффективной является third_sol(),
однако если сложность работы функции max() оценена мною не правильно,
в таком случае первая и вторая функции будут эквивалентны по сложности. В любом случае третья функция будет лучшим 
вариантом, так как проще в реализации и отсуствует рекурсивный вызов.
"""
print(first_sol(companies))
print(second_sol(companies))
print(third_sol(companies))
