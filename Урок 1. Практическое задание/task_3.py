"""
Задание 3.

Для этой задачи:
1) придумайте 1-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.


Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""
'''Решение 1 сложность O(n log n)
Сложность решения - лин. логарифмическая, поскольку самая сложная операция sorted, дающая
лин. логарифмическую сложность. Остальные операции - константная сложность. 
Это наиболее оптимальное решение.
'''
def search_max_1(dict_companys):
    return sorted(dict_companys.items(), key=lambda x: x[1], reverse=True)[:3]

''' Решение 2 сложность O(n)
Сложность решения - линейная, поскольку самая сложная операция - цикл for in, сложность которого 
прямопропорциональна размеру входящих данных. Так же есть лин. логарифмическая (sorted), остальные 
операции - константной сложности.
'''
def search_max_2(dict_companys):
    i = 1
    print('Второй вариант: ', end='')
    for item in sorted(dict_companys, key=dict_companys.get, reverse=True):
        print(item, dict_companys[item], end=' ')
        i += 1
        if i > 3:
            break
    return print()

dict_companys = {'Area': 10000, 'Boxis': 2000, 'VALIUM': 3000, 'Gallup': 500}

max_1 = search_max_1(dict_companys)
print(f'Первый вариант: {max_1}')

max_2 = search_max_2(dict_companys)