"""
Задание 3.

Для этой задачи:
1) придумайте 1-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.


Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""

companies_income = {
    'HP': 120000,
    'LG': 200000,
    'Sony': 150000,
    'Microsoft': 300000,
    'Yandex': 180000,
    'Google': 350000,
    'ASUS': 130000
}

"""Первое решение"""


# O(nlog(n)) Этот вариант лучше т.к. сложность меньше
def max_income_1(income_dict):
    my_list = list(income_dict.items())  # O(n)
    my_list.sort(key=lambda i: i[1], reverse=True)  # O(nlog(n))
    result = my_list[0:3]  # 3*O(1)
    return result  # O(1)


'''Второе решение'''


# O(n**2)
def max_income_2(income_dict):
    my_list = []  # 0(1)
    max_list = []  # 0(1)
    max_el = 0  # 0(1)
    result = {}  # 0(1)
    n = 0  # 0(1)
    for val in income_dict.values():  # O(n)
        my_list.append(val)  # O(1)
    while n < 3:  # O(1)
        max_el = max(my_list)  # O(1)
        max_list.append(max_el)  # O(1)
        my_list.pop(my_list.index(max_el))  # O(1)
        n += 1  # O(1)
    for key, value in income_dict.items():  # O(n)
        if value in max_list:  # O(n)
            result[key] = value  # O(1)

    return result


print(max_income_1(companies_income))
print(max_income_2(companies_income))
