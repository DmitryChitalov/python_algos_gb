"""
Задание 3.

Для этой задачи:
1) придумайте 1-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.


Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""
company_dict = {'компания_1': 45800, 'компания_2': 8900, 'компания_3': 23589, 'компания_4': 45678, 'компания_5': 45722,
                'компания_6': 7857, 'компания_7': 79867, 'компания_8': 23789, 'компания_9': 7892, 'компания_10': 2370}


def max_profit_dict():
    """Функция возвращает словарь из трех компаний с максимальным доходом.
    Алгоритм 1:
    Перебираем словарь, по ключу записываем значение в список. Получаем список со значением прибылей. Сортируем список
    по возрастанию. Перебираем в цикле последние три элемента списка (три макс значения). Внутри этого перебираем
    словарь с компаниями, находим компанию с подходящим значением в условии и записываем в новый словарь компанию
    по ключу и значению. Возвращаем резульстат в виде словаря.
    Сложность: O(N^2) - квадратичная
    Аналитика: Вероятно лишним будет создание нового словаря. Сам метод sort достаточно нагружен. Тут не вижу пока как
    можно избавиться от него. Самый плохой момент, цикл внутри цикла. Но не нашел пока иного решения, как получить
    ключ по значению в словаре. Значительно проще будет если поменять местами ключ и значение в исходном словаре.
    """
    my_list = []
    dict_result = {}                            # O(1) - константа
    for el in company_dict:                     # O(N) - линейная
        my_list.append(company_dict[el])        # O(1) - константа
    my_list.sort()                              # O(N Log N) - линейно - логарифмическая
    for el in my_list[-3:]:                     # O(N^2) - квадратичная, вложенный цикл
        for key in company_dict:
            if el == (company_dict[key]):       # O(1) - константа
                dict_result.update({key: el})   # O(1) - константа
    return dict_result                          # O(1) - константа


print(max_profit_dict())

company_list = [[45800, 'компания_1'], [8900, 'компания_2'], [23589, 'компания_3'], [45678, 'компания_4'],
[45722, 'компания_5'], [7857, 'компания_6'], [79867, 'компания_7'], [23789, 'компания_8'],
[7892, 'компания_9'], [2370, 'компания_10']]


def max_profit_list(data):
    """Функция возвращает словарь из трех компаний с максимальным доходом. В качестве данных принимает список списков
    Алгоритм 1:
    Перебирается в цикле список списков, очередной элемент сравнивается со значением дохода в первом элементе, и если
    он выше, то в переменную result присваивается значение дохода текущего элемента. в конце перебора получаем
    максимальное значение, записиваем его, вместе с названием компании в результирующий словарь и удаляем из входного
    списка значение, записанное как результат в словарь. И пока в этом словаре менее 3 элементов, повторяется все
    в цикле while. В тоге возвращается словарь с тремя компаниями у которых мах доход
    Сложность: O(N) - линейная
    Аналитика: Удалось избежать вложенного цикла for, но при этом много промежуточных переменных. В итоге оптимизация
    лучше чем в первом примере так же и потому что отсутствует встроеная функция сортировки. Этот метод будет рабоать
    быстрее
    """
    count = 0                       # O(1) - константа
    result_dict = {}                # O(1) - константа
    result = data[0][0]             # O(1) - константа
    ind = 0                         # O(1) - константа
    while len(result_dict) < 3:     # O(1) - константа
        for el in data:             # O(N) - линейная
            if el[0] >= result:     # O(1) - константа
                result = el[0]      # O(1) - константа, если выполнится условие
                ind = count         # O(1) - константа, если выполнится условие
            count += 1              # O(1) - константа
        result_dict.update({data[ind][1]: result})      # O(1) - константа
        data.pop(ind)                                   # O(1) - константа
        result = data[0][0]                             # O(1) - константа
        count = 0                                       # O(1) - константа
    return result_dict                                  # O(1) - константа


print(max_profit_list(company_list))