"""
Задание 3.

Для этой задачи:
1) придумайте 1-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.


Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""
d = {"one":100,
     "two":200,
    "three":400,
    "sony":300,
    "romashka":600,
    "borsh":500,
    "qwerty":800,
    "qazwsx": 900}

# O(N**3)
def get_max(d):
    dkey = []
    dvalue = []
    m = []
    for k, v in d.items():
        dkey.append(k)
        dvalue.append(v)
        mi = dvalue[0]
        for ii in range(2):
            for i in range(1, len(dvalue)):
                if mi < dvalue[i]:
                    mi = dvalue[i]
                    m.append(dkey[i])
                    if len(dkey) > 3:
                        m.pop(0)
    print(m)


# O(N**2)
# У этого решения ниже сложность
# Как мне кажется, оно более локонично и больше подходит под тему стеков, если я всё правильно понял
def get_max2(d):
    mv = []
    mk = []
    for k, v in d.items():
        mv.append(v)
        mk.append(k)
        if len(mv) > 1:
            for i in range(len(mv)):
                if i < len(mv)-1:
                    if mv[i] > mv[i+1]:
                        mv.append(mv.pop(i))
                        mk.append(mk.pop(i))
    print(mk[-3:])
