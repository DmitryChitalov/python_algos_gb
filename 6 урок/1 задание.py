"""
Задание 1.
Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи. Можно взять задачи с курса Основ или с текущего курса Алгоритмов
Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.
ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
import timeit
import memory_profiler

def get_info(func):
    def function(n):
        start_time = timeit.default_timer()
        start_memory = memory_profiler.memory_usage()
        func(n)
        finish_memory = memory_profiler.memory_usage()
        print(f'На выполнение ушло: {timeit.default_timer() - start_time} сек и {finish_memory[0] - start_memory[0]} Мб')
    return function

@get_info
def func_1(n):
    my_list = []
    for i in range(n):
        my_list.append(i)
    new_list = []
    a = 1
    b = 0
    n = len(my_list) - 1
    while n > 0:
        if my_list[a] > my_list[b]:
            new_list.append(my_list[a])
        n = n - 1
        a = a + 1
        b = b + 1
    #print(f"Результат: {new_list}")
    return

@get_info
def func_2(n):
    my_list = []
    for i in range(n):
        my_list.append(i)
    new_list = []
    a = 1000
    for i in my_list:
        if i > a:
            new_list.append(i)
        a = i
    #print(f"Результат: {new_list}")

count = 10
func_1(count)
func_2(count)
"""
Задача заключалась в составлении списка из эллементов исходного спсиска в котором последующий эллемент больше предвдущего.

Я привел два решения данной задачи их отличием является виды циклов такие как while и for in.
При длине исходного списка состоящено из 10 эллементов мы получаем следующие замеры:
    На выполнение первой функции ушло: 0.206230566 сек и 0.00390625 Мб
    На выполнение второй функци ушло: 0.20473936199999998 сек и 0.0 Мб
Из данных замеров можно сделать вывод, что данные функции затрачивают одинаковое время на их исполнение, 
но первая функция использует незначительно больше памяти чем вторая.

Выполним второй замер при длине исходного списка состоящено из 1000 эллементов мы получаем следующие замеры:
    На выполнение первой функции ушло: 0.205103487 сек и 0.0234375 Мб
    На выполнение второй функци ушло: 0.20637123399999996 сек и 0.00390625 Мб
Из данных замеров можно сделать вывод, что данные функции затрачивают также одинаковое время на их исполнение, 
но первая функция уже использует заметно больше колличество памяти чем вторая

Выполним последний третий замер при длине исходного списка состоящено из 10 000 000 эллементов мы получаем следующие замеры:
    На выполнение первой функции ушло: 3.761179878 сек и 80.1875 Мб
    На выполнение второй функци иушло: 1.8951422729999998 сек и -0.125 Мб
Из данных замеров можно сделать вывод, что первая функция затрачивают значительно больше времени на исполнение, 
и также первая функция использует намного больше памяти чем вторая

Использовал python 3.8 на MacOS
"""
@get_info
def func_2_1(n):
    def func_for_rec(n):
        if n < 1:
            return n
        else:
            return n + func_for_rec(n - 1)
    if func_for_rec(n) == n * (n + 1) / 2:
        return 'Для множества натуральных чисел равенство выполняется.'
    else:
        return 'Для множества натуральных чисел равенство не выполняется.'

@get_info
def func_2_2(n):
    sum = 0
    for i in range(n + 1):
        sum = sum + i
    if sum == n * (n + 1) / 2:
        return 'Для множества натуральных чисел равенство выполняется.'
    else:
        return 'Для множества натуральных чисел равенство не выполняется.'

count = 995
func_2_1(count)
func_2_2(count)
"""
Цель приведенных выше функций доказать или проверить, выполняется равенство: 1+2+...+n = n(n+1)/2 для множества
натуральных чисел, где n - любое натуральное число.

Замеры при колличестве натуральных чисел равным 10
На выполнение ушло: 0.20552353599999995 сек и 0.00390625 Мб
На выполнение ушло: 0.20400844100000004 сек и 0.0 Мб
Замеры при колличестве натуральных чисел равным 500
На выполнение ушло: 0.20655547400000007 сек и 0.55859375 Мб
На выполнение ушло: 0.20674658499999998 сек и 0.0 Мб
Замеры при колличестве натуральных чисел равным 995
На выполнение ушло: 0.20670178699999997 сек и 1.1875 Мб
На выполнение ушло: 0.20856356900000006 сек и 0.0 Мб

После выполнения данных замеров можно сделать вывод, что первой функции нужно некоторое количество памяти,
а вторая функция после ее выполнения не использует дополнительную память. 
Скорость выполнения при данном колличестве натуральных чисел примерно одинаково 
Проблема первой функции заключается в ограничении колличества натуральных чисел, так как она использует рекурсию
Использовал python 3.8 на MacOS
"""
