"""
Задание 1.

Реализуйте заполнение списка и словаря, сделайте замеры и сделайте выводы, обоснуйте результат.
Сделайте несколько операций с каждым из объектов, сделайте замеры и сделайте выводы, обоснуйте результат.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к двум своим функциям.
"""

import timeit


def time_dec(func):
    def wrapper(*args):
        print(f'Идёт выполнение...')
        start = timeit.default_timer()
        result = func(*args)
        finish = timeit.default_timer()
        print(f'Время выполнения: {finish - start}\n')
        return result
    return wrapper


@time_dec
def list_full(num):
    result = []
    for item in range(num):
        result.append(item)
    return result


@time_dec
def dict_full(num):
    result = dict()
    for item in range(num):
        result[item] = item
    return result


# Поробуем заполнить список и словарь 100 000 элементов:

LIMIT = 100000

print('Заполняем список:')
test_list_1 = list_full(LIMIT)  # -> ~ 0.005

print('Заполняем словарь:')
test_dict_1 = dict_full(LIMIT)  # -> ~ 0.007


# Добавление ключей и значений в словарь происходит чуть медленней, чем добавление элементов в конец списка.
# Это обусловлено процессом хеширования ключей.
# Однако, мы добавляли в список значения, состоящие из одного числа. Идентификаторами значений в списке
# являются индексы, мы не можем установить в списке иные идентификаторы для значений, то есть
# этот список не будет давать той же функциональности, что и словарь, представляющий собой
# хеш-таблицу соответствий ключ-значение.
# Для получения списка со схожей функциональностью заполним его не отдельными числами, а кортежами из двух чисел,
# где первое число будет идентификатором для второго:

@time_dec
def add_tuple_to_list(num):
    result = []
    for item in range(num):
        result.append((item, item))
    return result


print('Заполняем список кортежами:')
test_list_2 = add_tuple_to_list(LIMIT)  # -> ~ 0.012

# Время заполнения списка кортежами из двух элементов почти в два раза превышает время заполнения словаря
# тем же набором соответствий.

# Умножим значения элементов в списке и значения в словаре на число:


@time_dec
def mul_num_list(lst, num):
    for idx in range(len(lst)):
        lst[idx] *= num
    return lst


@time_dec
def mul_num_dict(dct, num):
    for item in dct:
        dct[item] *= num
    return dct


NUMBER = 5

print('Умножаем значения в списке:')
mul_num_list(test_list_1, NUMBER)  # -> ~ 0.006

print('Умножаем значения в словаре:')
mul_num_dict(test_dict_1, NUMBER)  # -> ~ 0.007

# Умножение значений в словаре происходит чуть медленнее, чем умножение значений в списке.
# Это обусловлено процессом хеширования ключей для получения позиции значения в хеш-таблице,
# в то время как получение значения из списка происходит напрямую по индексу.

# Посмотрим, сколько будет занимать получение индеса по значению элемента в списке:


@time_dec
def search_idx(lst, num):
    for item in range(num):
        lst.index(item)
    return lst


LIMIT = 10000

print('Заполняем список:')
test_list_1 = list_full(LIMIT)

print('Ищем индексы по значениям в списке:')
search_idx(test_list_1, LIMIT)  # -> ~ 0.502

# Невероятно долго! Метод index имеет сложность O(N). Это означает, например, что поиск элементов в списке кортежей
# по значениям одного из элементов кортежа займёт большое количество времени,
# в то время как получение значения по ключу из словаря имеет константную сложность и выполняется почти мгновенно.

# Приведённые выше замеры подводят нас к мысли, что для хранения связной информации
# (отображений одной информации на другую) в тех случаях, когда порядок следования элементов не важен,
# словарь является приоритетным вариантом.
