"""
Задание 2.*
Предложить еще какие-либо варианты (механизмы, подходы, библиотеки, идеи)
для оптимизации памяти и
доказать!!! (наглядно, кодом) их эффективность (на примере профилировщика)
"""
from timememit import timememit


# Проверим задачу про подсчет подстрок из урока 3.
@timememit
def count_substrings(s):
    bag = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            # Разница только в наличии hash() в этой строчке
            bag.add(hash(s[i:j]))
    return len(bag)-1


@timememit
def count_substrings_nohash(s):
    bag = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            bag.add(s[i:j])
    return len(bag)-1


txt = """
Задание 1.

Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.

Можно взять задачи с курса Основ
или с текущего курса Алгоритмов

Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""

print(count_substrings(txt), " подстрок")
print(count_substrings_nohash(txt), " подстрок")
# ---
# count_substrings: 0.4074 s, 1.199219 MiB
# 335826  подстрок
# count_substrings_nohash: 0.5043 s, 184.187500 MiB
# 335826  подстрок
# ---
# Эта задача опередила свое время. Для драматического эффекта
# ее нужно было давать на уроке 6. Если выигрыш по скорости
# всего 20%, то выигрыш по памяти более, чем в 150 раз!
# Получается, что замена строки на хеш является весьма
# эффективным методом экономии памяти и при этом
# не входит в 6 способов, рассмотренных на уроке.
#
# Однако, строго говоря, этот способ нельзя включать в список,
# потому что он 1) работает не для всех алгоритмов, а только
# для тех, которые не должны хранить строки в памяти;
# 2) потому что есть (хотя и очень малая) вероятность коллизии,
# что для некоторых применений недопустимо.
