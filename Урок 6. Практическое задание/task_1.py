"""
Задание 1.
Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи. Можно взять задачи с курса Основ или с текущего курса Алгоритмов

Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""


from memory_profiler import profile
import numpy as np


'''
из скриптов, которые делали на предыдущих уроках, не удалось быстро найти тот, 
который дает ненулевые результаты использования памяти (попробовал reverse num, решето Эратосфена - все по нулям). 
Поэтому использую свой простой пример.

Версия Python - 3.7. Разрядность Windows - 64.
'''


@profile
def my_func():

    a = []
    for i in range(100000):
        a.append(i)
    del a


my_func()

'''
Line #    Mem usage    Increment   Line Contents
================================================
    29     28.9 MiB     28.9 MiB   @profile
    30                             def my_func():
    31                             
    32     28.9 MiB      0.0 MiB       a = []
    33     32.8 MiB      0.0 MiB       for i in range(100000):
    34     32.8 MiB      0.6 MiB           a.append(i) 
    35     29.0 MiB      0.0 MiB       del a             


В строке 33 видим прирост использования памяти 3.9Mib за счет создания списка, хотя в строке 34 указано 0.6Mib. 
Возможно это связано с особенностями реализации @profile. 
К сожалению, @profile не показывает отрицательный increment, но мы видим, что
garbage collector очищает память на 3.8Mib при удалении в строке 35 единственной ссылки на созданный нами объект.
'''


@profile
def my_func2():
    a = np.arange(1, 100000, 1).tolist()
    del a


my_func2()


'''
Line #    Mem usage    Increment   Line Contents
================================================
    41     28.8 MiB     28.8 MiB   @profile
    42                             def my_func2():
    43     32.9 MiB      4.1 MiB       a = np.arange(1, 100000, 1).tolist()
    44     28.8 MiB      0.0 MiB       del a

При выполнении такой же задачи, numpy использует чуть больше памяти - 4.1Mib, что видно в строке 43 при создании списка.
При увеличении списка на порядок, тенденции к увеличению памяти у Numpy по сравнению c простым append нет, что
указывает, на то, что numpy использует те же механизмы создания списка.
'''


@profile
def my_func3():
    a = list(range(1, 100000))
    del a


my_func3()

'''
Line #    Mem usage    Increment   Line Contents
================================================
    84     27.6 MiB     27.6 MiB   @profile
    85                             def my_func3():
    86     31.5 MiB      3.8 MiB       a = list(range(1, 100000))
    87     27.6 MiB      0.0 MiB       del a

Создание аналогичного списка с помощью list дает использование памяти 3.8MiB.
В целом, с точки зрения использования по памяти, создание списков по трем вышеуказанным вариантам
существенно не отличается. 
'''