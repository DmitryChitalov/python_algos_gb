"""
Задание 1.
Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи. Можно взять задачи с курса Основ или с текущего курса Алгоритмов

Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
# Python 3.8.2
# Mac OS 64-bit
"""Файле sieve_example.py:
получается интересная картина, использование памяти (MiB) у функций почти равное. Разница
только в присвоенном генераторе, которое добавляет решету лишних 0,6 MiB. Однако число инцидентов не превышает
и 30 тысяч, по сравнению с проигрышными 278 тысячами у простой функции. я выбрал число n = 300, так как при равном 1000
скрипт вероятно пришлось бы оставить для вычислений на ночь"""


import example_task_1
from guppy import hpy


if __name__ == '__main__':
    h = hpy()
    n = 100
    i = 1
    for el in example_task_1.fact(n):
        # print(f'{i}! = {el}')
        i += 1
    print(h.heap())
"""В данном примере я взял простой скрипт из основ """
"""
Partition of a set of 69066 objects. Total size = 8005583 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0  20631  30  1947390  24   1947390  24 str
     1  15142  22  1064992  13   3012382  38 tuple
     2   4991   7   881494  11   3893876  49 types.CodeType
     3   9948  14   716478   9   4610354  58 bytes
     4   4874   7   662864   8   5273218  66 function
     5    744   1   635472   8   5908690  74 type
     6    744   1   415136   5   6323826  79 dict of type
     7    182   0   312520   4   6636346  83 dict of module
     8    690   1   282064   4   6918410  86 dict (no owner)
     9   1248   2    89856   1   7008266  88 types.WrapperDescriptorType
"""
