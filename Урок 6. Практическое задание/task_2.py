"""
Задание 2.
Предложите фундаментальные варианты оптимизации памяти
 и доказать (наглядно, кодом, если получится) их эффективность

Например, один из вариантов, использование генераторов
"""
from memory_profiler import profile
from guppy import hpy
h=hpy()
#1
@profile()
def func():
    arr = []
    for i in range(1, 20987):
        arr.append(i*i)
    return arr

print(func()) #при анализе через профайлер показывает инкремент на 14 строке - 0.6 и на апенде - 0.3, с учетом
# профайлера(18.8) - 19.6
print(h.heap())

@profile
def func_():
    arr = [i*i for i in range(1, 20987)]
    return arr

print(func_()) # при использовании генераторного списка - инкремент - 0.5, но с учетом профайлера (19.0)
# дает 19.6, в любом случае оптимизация исп-я памяти на лицо, 0.9 > 0.5 MiB.
'''
Основные моменты и методы оптимизации использования памяти  в питоне были рассмотрены на лекции. Как менее значимые, но 
возможные моментыдля оптимизации: избегать использование глобальных переменных, ограничение поиска в методе с исп-ем цикла
for i in range(10000):
    myLib.findMe(i)

findMe = myLib.findMe
    for i in range(10000):
        findMe(i)
'''
'''
Слабые ссылки (weak references)
Cтратегия оптимизации кода для эффективного потребления памяти предусматривает использование слабых ссылок.
Если на объект ведет только слабая ссылка, то ее не достаточно для его сохранения. 
Если на объект ведут только слабые ссылки, то он может быть очищен при сборе мусора.
В каких сценариях полезны слабые ссылки. Они помогают вести кэш или хранить сопоставления для очень больших и затратных объектов, которые занимают много пространства и памяти.


Глобальный блок интерпретатора (global interpreter lock)
Он не позволяет нескольким потокам (threads) выполнять код Python одновременно.
 Для каждого интерпретатора предусмотрен один блок. Внутри интерпретатора в единицу 
 времени может работать только один поток.
'''



