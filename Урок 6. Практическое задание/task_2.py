"""
Задание 2.
Предложите фундаментальные варианты оптимизации памяти
 и доказать (наглядно, кодом, если получится) их эффективность

Например, один из вариантов, использование генераторов


1) Использовать внешние библиотеки/пакеты
    Некоторые библиотеки python имеют эквивалент «C» с теми же функциями, что и исходная библиотека.
    Будучи написаны на “C”, они работают быстрее. Например, попробуйте использовать cPickle вместо использования pickle.
    Можно использовать <Cython>  , который является оптимизирующим статическим компилятором для обоих Python. Это
    расширение Python, поддерживающее функции и типы C. Код на нем выполняется быстрее и эффективнее.Также можно
    использовать пакет PyPy. Он включает компилятор JIT (Just-in-time), который делает код Python невероятно быстрым.
    PyPy можно дополнительно настроить для еще большего повышения производительности.


2) Использовать "Tuple"
    Для представления наборов данных в Python также есть встроенный тип tuple. Tuple это фиксированная структура или
    запись, но без имен полей. Для доступа к полю используется индекс поля. Поля tuple раз и навсегда связываются с
    объектами-значениями в момент создания экземпляра tuple. Экземпляры tuple вполне компактны, они занимают в памяти
    на 8 байт больше, чем экземпляры классов со __slots__.


3) Использовать Cython
    Есть один подход, основанный на использовании Cython. Его достоинство состоит в том, что поля могут принимать
    значения типов языка C. Дескрипторы для доступа к полям из чистого Python создаются автоматически. Например:

    cdef class Python:
        cdef public int x, y, z

    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    В этом случае экземпляры имеют еще меньший размер памяти:

    ob = Point(1,2,3)
    print(sys.getsizeof(ob))
    32

"""
