"""
Задание 3 *.
Сделать профилировку для скриптов с рекурсией и сделать,
можно так профилировать и есть ли 'подводные камни'
"""

from memory_profiler import profile, memory_usage


def decorator_function(func):
    m1 = memory_usage()

    def wrapper(*args):
        return_value, memory_used = func(*args)
        return return_value, memory_used

    print(f'Функция {func.__name__} кушает {memory_usage()[0] - m1[0]} Mib памяти!')
    return wrapper


@decorator_function
def fibonacci_sequence(n):
    m = memory_usage()
    if n <= 1:
        return [n, m]
    else:
        return [fibonacci_sequence(n - 1)[0] + fibonacci_sequence(n - 2)[0], m]


@profile
def call_fib_seq(inp):
    m1 = memory_usage()
    value = fibonacci_sequence(inp)
    print(f'Функция 1 кушает {memory_usage()[0] - m1[0]} Mib памяти!')
    return value


if __name__ == '__main__':
    # fibonacci_sequence(10)
    result, mem_used = call_fib_seq(5)
    print(f'Функция 2 кушает {mem_used[0]} Mib памяти!')

"""
Как можно увидеть выше - множество вариантов профилирования было испытанно и никакие не подошли, так как необходимо
делать замеры внутри вызова самой функции, что приводит к неудобству при разработке и, возможно, случайно оставленным
функции, тогда как декоратор можно легко применить и также легко убрать.
Итого было использованно 3 известных метода:
1) Использование декоратора profile из библиотеки memory_profiler. Результат неудовлетворительный: при каждом вызове
рекурсии выдается результат да еще и в котором ничего не считать.
2) Использование собственного профилировщика. Результат  неудовлетворительный: показывает только память на действия 
внутри функции т.к. сама обернутая функция вызывается в return.
3) Замер памяти до и после вызова функции. Результат  неудовлетворительный: все еще хуже чем в остальных случаях - 
показывает 0!
4) Замер памяти непосредственно в функции. Результат  неудовлетворительный: результат соответсвует выводу 
импортированного профилировщика и он точнее, получалось при каждом вызове смотреть вывод памяти, но я все таки не уверен
что это оно, т.к. значение было везде одинаковое. Скорее всего я что то упускаю
"""
