"""
Задание 1.

Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов!
(хотя бы 3 разных для получения оценки отл).
На каждый скрипт вы должны сделать как минимум по две реализации.

Можно взять задачи с курса Основ
или с текущего курса Алгоритмов

Результаты профилирования добавьте в виде комментариев к коду.
Обязательно сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и т.д.)

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""

# Переделаем программу поиска простых чисел методом решета Эратосфена. Используем numpy

from timeit import default_timer
from math import log
from numpy import array
from memory_profiler import memory_usage


# Декоратор, который будет замерять время работы и используемую память
def meas(func):
    def wrapper(*args, **kwargs):
        m1 = memory_usage()
        t1 = default_timer()
        res = func(args[0])
        t2 = default_timer()
        m2 = memory_usage()
        mem_diff = m2[0] - m1[0]
        time_diff = t2 - t1
        return res, mem_diff, time_diff
    return wrapper


# Исходная функция
@meas
def sieve(needed_simple_number):
    """
    Алгоритм с использованием решета Эратосфена. Сделано предположение, что n простых чисел точно найдется
    в n*(log(n)+2) числах
    Сложность: O(n*log(n)) - вложеные циклы, их сложность указана ниже
    """
    if needed_simple_number <= 0:
        return 0

    # по моей оценке число до которого будет needed_simple_number простых чисел (по материалам википедии):
    max_number = int(needed_simple_number * (log(needed_simple_number) + 2))

    # Создаем массив чисел от 0 до max_number. Индекс будет показывать какое число, а элемент = 0 сообщит, что
    # данный индекс не просто число. Индекс 0 и 1 будет не простыми
    a = [x for x in range(max_number + 1)]      # O(n)
    a[0] = 0
    a[1] = 0

    found_simple_numbers = 0
    i = 2
    while i <= max_number:                      # O(n)
        if a[i] != 0:
            found_simple_numbers += 1
            # чтобы не переберать лишние числа, остановим цикл при достижении нужного кол-ва простых чисел
            if found_simple_numbers >= needed_simple_number:
                break
            # первое кратное ему
            # будет в два раза больше
            j = i + i
            while j <= max_number:              # O(log(n)) - поскольку цикл начинается не с 1, а с j с шагом i
                # это число составное,
                # поэтому заменяем его нулем
                a[j] = 0
                # переходим к следующему числу,
                # которое кратно i
                # (оно на i больше)
                j = j + i
        i += 1

    return i


# Функция с использованием массива numpy
@meas
def sievenumpy(needed_simple_number):
    """
    Алгоритм с использованием решета Эратосфена. Сделано предположение, что n простых чисел точно найдется
    в n*(log(n)+2) числах
    Сложность: O(n*log(n)) - вложеные циклы, их сложность указана ниже
    """
    if needed_simple_number <= 0:
        return 0

    # по моей оценке число до которого будет needed_simple_number простых чисел (по материалам википедии):
    max_number = int(needed_simple_number * (log(needed_simple_number) + 2))

    # Создаем массив чисел от 0 до max_number. Индекс будет показывать какое число, а элемент = 0 сообщит, что
    # данный индекс не просто число. Индекс 0 и 1 будет не простыми

    a = array(range(max_number + 1)) # создаем array вместо списка

    a[0] = 0
    a[1] = 0

    found_simple_numbers = 0
    i = 2
    while i <= max_number:                      # O(n)
        if a[i] != 0:
            found_simple_numbers += 1
            # чтобы не переберать лишние числа, остановим цикл при достижении нужного кол-ва простых чисел
            if found_simple_numbers >= needed_simple_number:
                break
            # первое кратное ему
            # будет в два раза больше
            j = i + i
            while j <= max_number:              # O(log(n)) - поскольку цикл начинается не с 1, а с j с шагом i
                # это число составное,
                # поэтому заменяем его нулем
                a[j] = 0
                # переходим к следующему числу,
                # которое кратно i
                # (оно на i больше)
                j = j + i
        i += 1

    return i


i = int(input('Введите порядковый номер искомого простого числа: '))

num, mem, tim = sieve(i)

print(f"Простое число № {i} = {num}. Время работы - {tim}, память - {mem}")

num, mem, tim = sievenumpy(i)

print(f"Улучшенный метод. Простое число № {i} = {num}. Время работы - {tim}, память - {mem}")

print(
    """
На моем компьютере, при использовании массива из numpy время работы увеличивалось, 
но существенно снижался расход памяти
    """
)
