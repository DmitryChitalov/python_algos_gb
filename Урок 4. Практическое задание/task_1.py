"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Попробуйте оптимизировать код, чтобы снизить время выполнения
Проведите повторные замеры

Добавьте аналитику: что вы сделали и почему
"""

from timeit import timeit


def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr
def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr

def func_2(nums):
    return [i for i in nums if n % 2 == 0]


def func_3(nums):
    return [i for i, n in enumerate(nums) if n % 2 == 0]


def main_1(nums):
    func_1(nums)
    func_2(nums)
    func_3(nums)

print(timeit('func_1', setup='from __main__ import func_1'))
print(timeit('func_2', setup='from __main__ import func_2'))
print(timeit('func_3', setup='from __main__ import func_3'))
#Попробовал улучшить код с помощью генератора списка и встроенной функции enumerate(). При малых
#повторениях генератор и enumerate ускорят работу кода в 2 раза, но с увеличением количества
#повторений, разница сокращается до ~ 0,0001. Генератор хорош тем что он сразу составляет список, а
#не создает его по элементам как метод append, а функция enumerate() используется для упрощения
#прохода по коллекциям в цикле. Поэтому в данном случае лучше использовать генератор списка,
#он и быстрее и лаконичнее.

# 100 повторений            1000 повторений             100000 повторений       1000000 повторений
#6.900000000004125e-06      2.920000000000006e-05       0.002725200000000004    0.032023300000000005
#3.300000000004688e-06      2.5799999999999434e-05      0.002643699999999999    0.030590800000000015
#3.2000000000018125e-06     2.590000000000231e-05       0.002701199999999994    0.0326852
