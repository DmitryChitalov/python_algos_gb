"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Попробуйте оптимизировать код, чтобы снизить время выполнения
Проведите повторные замеры

Добавьте аналитику: что вы сделали и почему
"""

from timeit import timeit


def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


def func_2(nums):
    return [c for c, i in enumerate(nums) if i % 2 == 0]


print(timeit("""
func_1([1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3])
""", setup='from __main__ import func_1', number=100000))

print(timeit("""
func_2([1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3])
""", setup='from __main__ import func_2', number=100000))

"""
Проблемы исходного решения: 
1. Мы тратим время на высчитывание длины nums в цикле for, хотя можем сразу идти по nums
2. Мы каждый раз обращаемся к элементу исходного массива по индексу, затем проводим над ним действия для сравнения
Что сделал я: 
1. Сделал генератор (эксперименты с просто генератором показали, что выигрыша нет, это, скорее, вопрос красоты кода)
2. Изменил схему обращения по индексу на enumerate. Так как это встроенная функция, она работает быстро, плюс позволяет
пробежаться циклом сразу по исходному списку, который ей уже пронумерован
В итоге: 
Моё решение на тестах работает быстрее
"""
