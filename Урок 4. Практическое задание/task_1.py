"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Попробуйте оптимизировать код, чтобы снизить время выполнения
Проведите повторные замеры

Добавьте аналитику: что вы сделали и почему
"""
arr = [i for i in range(10 ** 4)]


def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


def func_2(nums=arr):
    """Использует генератор списков"""
    new_arr = [i for i in nums if nums[i] % 2 == 0]
    return new_arr


def func_3(nums=arr):
    """Использует фильтрующую функцию для списка"""
    return list(filter(lambda x: x % 2 == 0, nums))


def func_4(nums=arr):
    """Создает объект генератор, преобразует в список"""
    new_arr = list((i for i in nums if nums[i] % 2 == 0))
    return new_arr


if __name__ == '__main__':
    from timeit import timeit

    #  попробовал запись с импортом
    print('Время выполнения второго варианта при 10000 повторениях: ', timeit(
        'func_1(arr)',
        setup='from __main__ import func_1, arr',
        number=10000
    ))
    #   в оставшиеся варианты передал список как параметр по умолчанию, запись для вывода более лаконичная
    print(f'Время выполнения второго варианта при 10000 повторениях: {timeit(func_2, number=10000)}')
    print(f'Время выполнения третьего варианта при 10000 повторениях: {timeit(func_3, number=10000)}')
    print(f'Время выполнения четвертого варианта при 10000 повторениях: {timeit(func_4, number=10000)}')

    """
    Из четырех вариантов реализации быстрее всего работает генератор списка. В отличие от обычного цикла ему не нужно
    затрачивать время на вызов метода append на каждй итерации. чтобы заполнить список. Вариант использования
    фильтрующей функции не дает выиогрыша по сравнению с обычным циклом при большом количестве интераций, так как
    необходимо для каждого элемента вызывать фильтрующую функцию для проверки соответствия условию фильтрации.
    Вариант создания объекта генератора и преобразования его в список работает немного быстрее, чем обычная итерация по 
    циклу. Возможно, это связано с тем, что внутренние преобразования такого типа выполняются на С, поэтому
    работают быстрее обычного цикла.
    """
