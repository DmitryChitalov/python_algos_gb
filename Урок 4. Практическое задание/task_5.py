"""
Задание 5.*

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма
"""
from timeit import timeit


def simple(i):
    """Без использования «Решета Эратосфена», сложность выше квадратичной"""
    count = 1
    n = 2
    while count <= i:  # O(N)
        t = 1
        is_simple = True
        while t <= n:  # O(N)
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def find_prime(n):
    """
    Алгоритм находит простое число с порядковым номером n
    Сложность выше O(N*log(log(N)))
    :param n: порядковый номер простого числа
    :return: простое число c порядковым номером n
    """
    def eratosthenes(n):
        """
        Алгоритм решета Эратосфена поиска всех простых чисел до n
        """
        # список заполняется значениями от 0 до n
        a = []
        for i in range(n + 1):
            a.append(i)

        # Вторым элементом является единица,
        # которую не считают простым числом
        # забиваем ее нулем.
        a[1] = 0

        # начинаем с 3-го элемента
        i = 2
        while i <= n:
            # Если значение ячейки до этого
            # не было обнулено,
            # в этой ячейке содержится
            # простое число.
            if a[i] != 0:
                # первое кратное ему
                # будет в два раза больше
                j = i + i
                while j <= n:
                    # это число составное,
                    # поэтому заменяем его нулем
                    a[j] = 0
                    # переходим к следующему числу,
                    # которое кратно i
                    # (оно на i больше)
                    j = j + i
            i += 1

        # Превращая список во множество,
        # избавляемся от всех нулей кроме одного.
        a = set(a)
        # удаляем ноль
        a.remove(0)
        return sorted(list(a))

    i = n  # поиск простого числа по номеру
    arr = []
    while len(arr) < n:  # arr - список всех простых чисел, которые находим решетом
        # в цикле идем, пока длина списка не станет больше n, т.е.
        # мы нашли больше или равно простых чисел, чем нужно
        arr = eratosthenes(i)  # находим список простых чисел, сложность O(N*log(log(N)))
        i *= 2  # если длина списка закончилась, а простое число с номером n не нашли - увеличиваем длину в два раза
        # и пересчитываем список еще раз, нет оценки сколько таких итераций придется сдеалть - оценить сложно
    return arr[n - 1]  # возвращаем простое число с номером n


print('10 simple: ', timeit('simple(10)', globals=globals(), number=10000))
print('10 erato: ', timeit('find_prime(10)', globals=globals(), number=10000))
print('100 simple: ', timeit('simple(100)', globals=globals(), number=10000))
print('100 erato: ', timeit('find_prime(100)', globals=globals(), number=10000))
print('1000 simple: ', timeit('simple(1000)', globals=globals(), number=10000))
print('1000 erato: ', timeit('find_prime(1000)', globals=globals(), number=10000))


"""
10 simple:  0.278989792
10 erato:  0.26476703700000004
100 simple:  27.164482993
100 erato:  5.973717970000003
1000 simple:  4990.251226947999
1000 erato:  77.52403122800024

Видно, что чем больше порядок искомого поростого числа, тем оптимальнее относительно простого перебора 
работает метод решета Эратосфена. Связано это с тем, что метод решета Эратосфена по сложности
ближе к O(N*log(N)), а перебор - ближе к квадратичной сложности.
"""