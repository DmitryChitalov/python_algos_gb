"""
Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

Укажите формулу сложности О-нотация каждого алгоритма
и сделайте обоснвование рез-ам
"""

from timeit import timeit
from math import log


def simple(i):
    """Без использования «Решета Эратосфена»
    сложность О((n*log(n))**2), вложенные цикты, сложность их указана ниже.
    Перемножение их сложности дает искомую. Остальные строки имеют сложность O(1)
    """
    count = 1
    n = 2
    # O(n*log(n)) - поскольку кол-во циклов будет превышать кол-во простых чисел примерно в эту величину
    while count <= i:           # O(n*log(n))
        t = 1
        is_simple = True
        # O(n*log(n)) - максимальное кол-во циклов соответствует n*log(n)
        while t <= n:           # O(n*log(n))
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def sieve(needed_simple_number):
    """
    Алгоритм с использованием решета Эратосфена. Сделано предположение, что n простых чисел точно найдется
    в n*(log(n)+2) числах
    Сложность: O(n*log(n)) - вложеные циклы, их сложность указана ниже
    """
    if needed_simple_number <= 0:
        return 0

    # по моей оценке число до которого будет needed_simple_number простых чисел (по материалам википедии):
    max_number = int(needed_simple_number * (log(needed_simple_number) + 2))

    # Создаем массив чисел от 0 до max_number. Индекс будет показывать какое число, а элемент = 0 сообщит, что
    # данный индекс не просто число. Индекс 0 и 1 будет не простыми
    a = [x for x in range(max_number + 1)]      # O(n)
    a[0] = 0
    a[1] = 0

    found_simple_numbers = 0
    i = 2
    while i <= max_number:                      # O(n)
        if a[i] != 0:
            found_simple_numbers += 1
            # чтобы не переберать лишние числа, остановим цикл при достижении нужного кол-ва простых чисел
            if found_simple_numbers >= needed_simple_number:
                break
            # первое кратное ему
            # будет в два раза больше
            j = i + i
            while j <= max_number:              # O(log(n)) - поскольку цикл начинается не с 1, а с j с шагом i
                # это число составное,
                # поэтому заменяем его нулем
                a[j] = 0
                # переходим к следующему числу,
                # которое кратно i
                # (оно на i больше)
                j = j + i
        i += 1

    return i


i = int(input('Введите порядковый номер искомого простого числа: '))

print(simple(i))
print(sieve(i))

print(
    "simple - ",
    timeit(
        'simple(i)',
        setup='from __main__ import simple, i',
        number=100))
print(
    "sieve - ",
    timeit(
        'sieve(i)',
        setup='from __main__ import sieve, i',
        number=100))

print(
    """
Алгоритм на основе решета Эратосфена эффективнее, т.к. он не проверяет все числа подряд, а отсеивает. 
В минус алгоритма можно записать необходимость знать до какого числа искать нужное кол-во простых чисел.
    """
)