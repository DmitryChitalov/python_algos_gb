"""
Задание 5.*

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма
"""

from timeit import timeit

i = 100


def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def eratosfen(n):
    a = []
    for i in range(n + 1):
        a.append(i)
    a[1] = 0
    i = 2
    while i <= n:
        if a[i] != 0:
            j = i + i
            while j <= n:
                a[j] = 0
                j = j + i
        i += 1
    a = set(a)
    a.remove(0)
    return a

print(timeit('simple(i)', 'from __main__ import simple, i', number=1000))
print(timeit('eratosfen(i)', 'from __main__ import eratosfen, i', number=1000))


"""
Результаты:

2.0328994000000002
0.028610400000000258

Вариант Решето Эратосфера работает значительно быстрее простого поиска, поскольку
в первом варианте мы используем перебор делителей, а также сравнение числа, 
совершаем арифметические операции

В варианте решета мы как бы просеиваем число, используя индексы.
Просеивание идет по правилу, что "сложные числа всегда можно представить как произведение простых",
Также сложные числа заменяются нулями. Компьютеру требуется гораздо меньше времени на вычисления, за счет
этого этот алгоритм и выигрывает

"""

