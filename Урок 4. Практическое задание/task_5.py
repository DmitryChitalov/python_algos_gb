
"""
Задание 5.*

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма
"""
from timeit import timeit
import sys
sys.setrecursionlimit(100000)

def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def sieve(n):
    numb = n*n
    a = []
    for i in range(numb + 1):
        a.append(i)
    a[1] = 0
    i = 2
    while i <= numb:
        if a[i] != 0:
            j = i + i
            while j <= numb:
                a[j] = 0
                j = j + i
        i += 1
    a = set(a)
    a.remove(0)
    a_list = list(a)
    a_list.sort()
    return a_list[n-1]


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(i))
print('С использованием сита')
print(sieve(i))
print('Время первого решения')
print(
    timeit(
        'simple(i)',
        globals=globals(),
        number=100))
print('Время второго решения')
print(
    timeit(
        'simple(i)',
        globals=globals(),
        number=100))
'''

Принципы нахождения простого числа абсолютно различны, так как в первом случае мы двигаемся вперед и при совпадении
условий выходим из цикла.
При использовани  решета нам нужно построить числовой ряд и забить его 0 а потом через множество отсортировать 
простые числа. Сложность у меня возникла с определением какой длинны должен был быть ряд чисел, я решил возвести
в квадрат порядковый номер искомого числа, но судя по результатам 1000 простое число вполне хватило бы 10000, а не 
1000000 как у меня. Как то надо было использовать прерывание цикла наверно но пока не догадался как. Пробовал 
делать через рекурсию и другие решения, но они все были либо дольше либо неправильно находили простое число.
Сложность решета в википедии написана O(n ln ln n), я думаю что сложность обоих функций O(N^2) так как надо перебирать
список внутри списка.

Введите порядковый номер искомого простого числа: 10
29
С использованием сита
29
Время первого решения
0.0023189010000002064
Время второго решения
0.002198769000000045

Введите порядковый номер искомого простого числа: 100
541
С использованием сита
541
Время первого решения
0.21295277099999987
Время второго решения
0.20453294300000024

Введите порядковый номер искомого простого числа: 1000
7919
С использованием сита
7919
Время первого решения
34.480781447000005
Время второго решения
34.389647002

'''