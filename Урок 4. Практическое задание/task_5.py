"""
Задание 5.*

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма
"""
from timeit import timeit


def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def eratosphen(n):
    # список заполняется значениями от 0 до n
    a = []
    if n < 40:
        max = n * (n // 2 + 1)
    elif n < 100:
        max = n * (n // 5 + 1)
    else:
        max = n * (n // 10 + 1)
    for i in range(max):
        a.append(i)
    # Вторым элементом является единица, которую не считают простым числом забиваем ее нулем.
    a[1] = 0
    # начинаем с 3-го элемента
    i = 2
    while i < max:
        # Если значение ячейки до этого не было обнулено, в этой ячейке содержится простое число.
        if a[i] != 0:
            # первое кратное ему
            # будет в два раза больше
            j = i + i
            while j < max:
                # это число составное, поэтому заменяем его нулем
                a[j] = 0
                # переходим к следующему числу, которое кратно i (оно на i больше)
                j = j + i
        i += 1
    # Превращая список во множество, избавляемся от всех нулей кроме одного.
    a = set(a)
    # удаляем ноль
    a.remove(0)
    # конвертируем в список
    lst = list(a)
    # сортируем
    lst.sort()
    # получаем нужный элемент
    return lst[n - 1]


m = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(m))
print(eratosphen(m))

print(
    timeit(
        "simple(m)",
        setup='from __main__ import simple, m',
        number=1000))

print(
    timeit(
        "eratosphen(m)",
        setup='from __main__ import eratosphen, m',
        number=1000))


"""
Введите порядковый номер искомого простого числа: 5
11
11
0.0063452480000001366
0.004850680999999968
=====
Введите порядковый номер искомого простого числа: 10
29
29
0.022210345999999825
0.018153147000000036
=====
Введите порядковый номер искомого простого числа: 50
229
229
0.5300324490000001
0.19725874199999982
=====
Введите порядковый номер искомого простого числа: 100
541
541
2.5669752420000007
0.4447864939999997
=====
Введите порядковый номер искомого простого числа: 500
3571
3571
97.003738136
11.478621716000006

Эратосфен в костыльном виде работает быстрее
Необходимо вычислять максимально близкое значение величины испытуемого массива чисел - пока сделал несколько отсечек опытным путем 
"""
