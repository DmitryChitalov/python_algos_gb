"""
Задание 5.*

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма
"""
import timeit


def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def erat_1(n_user, n=200000):
    # Функция поиска простого числа по его номеру в воображаемом списке по алгоритму 'решето Эратосфена'
    a = list(range(n + 1))  # список заполняется значениями от 0 до n
    a[1] = 0    # Вторым элементом является единица, которую не считают простым числом забиваем ее нулем.
    k = 0       # Счетчик простых чисел
    i = 2       # начинаем с 3-го элемента

    while i <= n:
        if a[i] != 0:  # Если значение ячейки до этого не было обнулено, в этой ячейке содержится простое число.
            k += 1
            if n_user == k:
                break
            j = i + i       # первое кратное ему будет в два раза больше
            while j <= n:
                a[j] = 0    # это число составное, поэтому заменяем его нулем
                j = j + i   # переходим к следующему числу, которое кратно i (оно на i больше)
        i += 1

    return i


def verify():
    i = int(input('Введите порядковый номер простого числа '))           # simple(10000) -> 104729
    print(f'simple: {i} простое число = {simple(i)}')
    print(f'erat_1: {i} простое число = {erat_1(i)}')


# verify()

i_number = [(10, 1000), (100, 100), (1000, 5)]
for j, k in i_number:
    number = k
    i = j
    timeit1 = timeit.timeit("simple(i)", setup="from __main__ import simple, i", number=10)  # 29
    timeit2 = timeit.timeit("erat_1(i)", setup="from __main__ import erat_1, i", number=10)  # 1.15
    print(f'simple({j}) number={k} -> {timeit1}')
    print(f'erat_1({j}) number={k} -> {timeit2}\n')

"""
По результатам замеров:
При поиске простого числа небольшого номера, 'первая' функция работает быстрее
По мере увеличения номера простого числа время поиска значительно увеличивается
Функция поиска по алгоритму 'решето Эратосфена' зависит от количества элементов в первоначальном списке. 
    Как по времени, так и по функционированию
Результаты замеров времени:

simple(10) number=1000 -> 0.00038599999999999746
erat_1(10) number=1000 -> 0.5530879

simple(100) number=100 -> 0.028790699999999947
erat_1(100) number=100 -> 0.7183532

simple(1000) number=5 -> 5.8925654000000005
erat_1(1000) number=5 -> 0.8188102000000006

i = 10 000, number = 10         результаты замеров соответственно   1251.6    и 1.15
# print(timeit.timeit("simple(i)", setup="from __main__ import simple, i", number=10))    # 1251.60
# print(timeit.timeit("erat_1(i)", setup="from __main__ import erat_1, i", number=10))    # 1.15

Сложность алгоритмов  
semple() O(n!);     erat_01() O(n) 
"""