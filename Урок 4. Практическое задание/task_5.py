"""
Задание 5.*

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма
"""


import timeit


def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(i))


def resheto(x):
    a = []
    n = 0
    for j in range(n + 1):
        a.append(j)
    a[1] = 0
    m = 2

    while m < n:

        if a[m] != 0:
            j = m + m
            while j < n:
                a[j] = 0
                j = j + m

        m = m + 1

    a = set(a)
    a.remove(0)

    a = list(a)
    a.sort()
    return a[x - 1]


x = int(input('Введите порядковый номер искомого простого числа: '))
print(resheto(x))
print(timeit.timeit("simple", setup="from __main__ import simple"))
print(timeit.timeit("resheto", setup="from __main__ import resheto"))
"""
если и=10 и х=10 , то на втором алгоритме n=50 вполне  достаточна
тогда их скорость выпольнении 
0.011287500000000783
0.011180600000000318
 а если и=100 и х=100 , то на втором алгоритме n=600 вполне  достаточна
тогда их скорость выпольнении 
0.012664699999999307
0.012599999999999945
а если и=1000 и х=1000 , то на втором алгоритме n=2000 вполне  достаточна
тогда их скорость выпольнении 
0.011483700000000319
0.011248999999999398

и у обоих алгоритмов сложность O(n^2)
"""
