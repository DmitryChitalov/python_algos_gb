"""
Задание 4.

Приведены два алгоритма. В них определяется число,
которое встречается в массиве чаще всего.

Сделайте профилировку каждого алгоритма через timeit

Попытайтесь написать третью версию, которая будет самой быстрой.
Сделайте замеры и опишите, получилось ли у вас ускорить задачу.
"""
from collections import Counter
from timeit import timeit
import numpy as np

array = [57, 1, 2, 64, 56, 0, 49, 25, 69, 75, 9, 97, 71, 92, 7, 59, 33, 54, 67, 64, 34, 66, 61, 42, 44, 36, 32, 28, 13, 40]
print(array)
def func_1():
    m = 0
    num = 0
    for i in array:
        count = array.count(i)
        if count > m:
            m = count
            num = i
    return f'Чаще всего встречается число {num}, ' \
           f'оно появилось в массиве {m} раз(а)'


def func_2():
    new_array = []
    for el in array:
        count2 = array.count(el)
        new_array.append(count2)

    max_2 = max(new_array)
    elem = array[new_array.index(max_2)]
    return f'Чаще всего встречается число {elem}, ' \
           f'оно появилось в массиве {max_2} раз(а)'


def func_3():
    foo = Counter(array).most_common()[0]
    return f'Чаще всего встречается число {foo[0]}, ' \
           f'оно появилось в массиве {foo[1]} раз(а)'


def func_4():
    foo = (np.bincount(array)).argmax()
    return f'Чаще всего встречается число {foo}, ' \
           f'оно появилось в массиве {array.count(foo)} раз(а)'


def func_5():
    foo = max(array, key=array.count)
    return f'Чаще всего встречается число {foo}, ' \
           f'оно появилось в массиве {array.count(foo)} раз(а)'


def func_6():
    bar = []
    p = '\n'
    foo = [i for i in Counter(array).most_common() if i[1] != 1]
    if len(foo) == 1:
        return f'Чаще всего встречается число {foo[0][0]}, ' \
              f'оно появилось в массиве {foo[0][1]} раз(а)'
    else:
        for i in range(len(foo)):
            bar.append(f'Число {foo[i][0]} оно появилось в массиве {foo[i][1]} раз(а),')
        return f'Наиболее встречающиеся числа:{p}{p.join(list(bar))}'


print(timeit("func_1()", setup="from __main__ import func_1, array", number=100000))
print(timeit("func_2()", setup="from __main__ import func_2, array", number=100000))
print("*"*100)
print(timeit("func_3()", setup="from __main__ import func_3, array", number=100000))
print(timeit("func_4()", setup="from __main__ import func_4, array", number=100000))
print(timeit("func_5()", setup="from __main__ import func_5, array", number=100000))
print(timeit("func_6()", setup="from __main__ import func_6, array", number=100000))

print(func_1())
print(func_2())
print(func_3())
print(func_4())
print(func_5())
print("*"*100)
print(func_6())

'''
func_1 и func_2 данные нам изначально функции , func_3,func_4,func_5,func_6 - самописные функции, реализация попытки 
найти оптимальный алгоритм выполнения данной задачи
Для тестирования данных алгоритма разберем 2 случая
1) Количество элементов в массиве до 8 штук, элементы положительные числа
2) Количество элементов в массиве до 30 штук, элементы положительные числа
Упростим себе задачу тестируя на положительных числах потому что funk_4 работает только с ними (определенной разницы 
между положительными и отрицательными нет)

1) при количестве элементов в массиве  - 7. Входные данные  - [86, 99, 50, 21, 99, 16, 42]  

Результаты работы:
func_1 - 0.2997586
func_2 - 0.4038583
****************************************************************************************************
func_3 - 0.6405055
func_4 - 0.8659965999999999
func_5 - 0.3196665999999997
func_6 - 0.7790702
****************************************************************************************************
Как мы видим из полученных результатов func_1 работает быстрее других, но если увеличить количество элементов в массиве:

2) при количестве элементов в массиве  - 100. Входные данные  - 
[57, 1, 2, 64, 56, 0, 49, 25, 69, 75, 9, 97, 71, 92, 7, 59, 33, 54, 67, 64, 34, 66, 61, 42, 44, 36, 32, 28, 13, 40]

Результаты работы:
func_1 - 2.9315122
func_2 - 3.1715905999999996
****************************************************************************************************
func_3 - 1.0971916999999998
func_4 - 1.7685003999999989
func_5 - 2.799766100000001
func_6 - 1.4010742999999994

Из результатов мы видим, что при увеличении количества элементов в массиве скорость работы func_1 увеличивается а func_3 
уменьшается по сравлению с func_1. 

Функция func_6 выводит ответ на поставленную задачу, даже если количесво повторяемых элементов больше 1
Считаю ее самой оптимальной из изложенных выше.

Функция func_4 показала наихудшее время среди всех представленных на всех этапах тестирования 
'''