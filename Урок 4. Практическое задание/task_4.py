"""
Задание 4.

Приведены два алгоритма. В них определяется число,
которое встречается в массиве чаще всего.

Сделайте профилировку каждого алгоритма через timeit

Попытайтесь написать третью версию, которая будет самой быстрой.
Сделайте замеры и опишите, получилось ли у вас ускорить задачу.
"""

import timeit

array = [1, 3, 1, 3, 4, 5, 1]
# array = [1, 3, 1, 3, 4, 5, 1, 3, 1, 3, 4, 5, 1, 3, 1, 3, 4, 5, 1, 3, 1, 3, 4, 5, 1, 3, 1, 3, 4, 5, 1, 3, 1, 3, 4, 5]


def func_1():
    m = 0
    num = 0
    for i in array:
        count = array.count(i)
        if count > m:
            m = count
            num = i
    return f'Чаще всего встречается число {num}, ' \
           f'оно появилось в массиве {m} раз(а)'


def func_2():
    new_array = []
    for el in array:
        count2 = array.count(el)
        new_array.append(count2)

    max_2 = max(new_array)
    elem = array[new_array.index(max_2)]
    return f'Чаще всего встречается число {elem}, ' \
           f'оно появилось в массиве {max_2} раз(а)'


def func_3():
    new_dic = {}
    freq_num = None
    for el in array:
        if not new_dic.get(el):
            new_dic[el] = 1
        else:
            new_dic[el] += 1
    appearance = max(new_dic.values())
    for dict_items in new_dic:
        if new_dic[dict_items] == appearance:
            freq_num = dict_items
    return f'Чаще всего встречается число {freq_num}, ' \
           f'оно появилось в массиве {appearance} раз(а)'


def func_3a():
    new_dic = {}
    for el in set(array):
        new_dic[el] = 0
    freq_num = []
    for el in array:
        new_dic[el] += 1
    appearance = max(new_dic.values())
    for dict_items in new_dic:
        if new_dic[dict_items] == appearance:
            freq_num.append(dict_items)
    return f'Чаще всего встречается число(a) {freq_num}, ' \
           f'оно(и) появилось(ись) в массиве {appearance} раз(а)'


print(func_1())
print(func_2())
print(func_3())
print(func_3a())

print(
    timeit.timeit(
        stmt="func_1()",
        setup="from __main__ import func_1",
        number=1000))

print(
    timeit.timeit(
        stmt="func_2()",
        setup="from __main__ import func_2",
        number=1000))

print(
    timeit.timeit(
        stmt="func_3()",
        setup="from __main__ import func_3",
        number=1000))

print(
    timeit.timeit(
        stmt="func_3a()",
        setup="from __main__ import func_3a",
        number=1000))

"""
Чаще всего встречается число 1, оно появилось в массиве 3 раз(а)
Чаще всего встречается число 1, оно появилось в массиве 3 раз(а)
Чаще всего встречается число 1, оно появилось в массиве 3 раз(а)
Чаще всего встречается число(a) [1], оно(и) появилось(ись) в массиве 3 раз(а)
0.00477941600001941
0.008052925999891158
0.007278098999904614
0.009769388000222534

Профилировка timeit показывает, что оба алгоритма соизмеримы по времени исполнения; с легким преимуществом первого.

Моя третья версия использует в процессе поиска словарь, который в качестве ключей использует уникальные значения
массива, а их значения инкрементируются при каждом повторении соответствующего элемента в процессе обхода массива.
На приведенном примере входного массива мой алгоритм показывает небольшое отставание от первых двух, но при увеличении
входного массива он уходит в заметный отрыв от них:

Чаще всего встречается число 1, оно появилось в массиве 12 раз(а)
Чаще всего встречается число 1, оно появилось в массиве 12 раз(а)
Чаще всего встречается число 3, оно появилось в массиве 12 раз(а)
Чаще всего встречается число(a) [1, 3], оно(и) появилось(ись) в массиве 12 раз(а)
0.07307852600024489
0.11649047700029769
0.03575445399974342
0.05874363600014476

Вариант алгоритма 3а устраняет общий недочёт, в результате которого на выходе имеется только одно (первое / последнее) 
из частовстречающихся чисел. Если же таких чисел несколько, то усовершенствованный алгоритм выводит их список. 
Но этот алгоритм, вполне ожидаемо, уступает по времени исходной реализации (но с ростом длины массива до порядка
сотен "3а" начинает стабильно выигрывать по времени).
"""
