"""
Задание 4.

Приведены два алгоритма. В них определяется число,
которое встречается в массиве чаще всего.

Сделайте профилировку каждого алгоритма через timeit

Попытайтесь написать третью версию, которая будет самой быстрой.
Сделайте замеры и опишите, получилось ли у вас ускорить задачу.

Без аналитики задание считается не принятым
"""

from timeit import timeit
from random import randint


# array = [1, 3, 1, 3, 4, 5, 1]
array = [randint(0, 9) for i in range(100)]


def func_1():
    m = 0
    num = 0
    for i in array:
        count = array.count(i)
        if count > m:
            m = count
            num = i
    return f'Чаще всего встречается число {num}, ' \
           f'оно появилось в массиве {m} раз(а)'


def func_2():
    new_array = []
    for el in array:
        count2 = array.count(el)
        new_array.append(count2)

    max_2 = max(new_array)
    elem = array[new_array.index(max_2)]
    return f'Чаще всего встречается число {elem}, ' \
           f'оно появилось в массиве {max_2} раз(а)'


def func_3():
    el = max(set(array), key=array.count)
    max_3 = array.count(el)
    return f'Чаще всего встречается число {el}, ' \
           f'оно появилось в массиве {max_3} раз(а)'


N = 10000

print(array)

print(
    "func_1 - ",
    timeit(
        'func_1()',
        setup='from __main__ import func_1',
        number=N))
print(
    "func_2 - ",
    timeit(
        'func_2()',
        setup='from __main__ import func_2',
        number=N))
print(
    "func_3 - ",
    timeit(
        'func_3()',
        setup='from __main__ import func_3',
        number=N))

print(func_1())
print(func_2())
print(func_3())

print(
    """
1я функция решает задачу перебором всех элементов списка и подсчета частоты их вхождения.
Не самый оптимальный способ, т.к. по повторным элементам подсчет их количества повторяется.

2я функция работает похожим образом, но использует дополнительный список, где хранит количичество
вхождений каждого элемента. Работа с дополнительным списком замедляет время работы

3я функция использует встроенные функции Питона. Она создает множество уникальных элементов. И находит элемент
с максимальном количеством вхождений. Самая быстрая реализация - во первых подсчет идет только по уникальным элементам,
во вторых используются внутренние функции

Еще одно наблюдение, если два числа имеют одинаковое кол-во вхождений, то функции могут вернуть разные результаты
    """
)
