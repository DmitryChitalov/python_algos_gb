"""
Задание 1.
Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 3-5 ваших программы или несколько
вариантов кода для одной и той же задачи. Можно взять задачи с курса Основ или с текущего курса Алгоритмов

Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

# Не используя библиотеки для парсинга, распарсить файл
# логов web-сервера nginx_logs.txt и найти IP адрес спамера и количество отправленных им запросов

from collections import Counter
from profile_code import profile_code


@profile_code(100)
def spammer_catch():
    with open('nginx_logs.txt') as log_file:
        data_list = []
        for line in log_file:
            item = line.split()
            data_list.append(item[0])

    ip_list = list({element for element in data_list})

    ip_dict = dict().fromkeys(ip_list, 0)

    for el in data_list:
        ip_dict[el] += 1

    result = max(ip_list, key=lambda x: ip_dict[x])

    return result, ip_dict[result]


@profile_code(100)
def spammer_catch_refactor():
    with open('nginx_logs.txt') as log_file:
        data_list = (line.split()[0] for line in log_file)
        result = Counter(data_list).most_common(1)

    return result[0]


print('\nНеоптимизированный вариант:')
spammer_catch()
# Время: 27.309549700000012, Память: 3.65234375

print('\nОптимизированный вариант:')
spammer_catch_refactor()
# Время: 27.202284100000004, Память: 0.24609375

# Замеры выполнялись отдельным запуском каждого варианта (ненужный комментировался) для получения
# релевантных значений по занимаемой памяти (взята суммарная использованная память за все запуски).
# Скрипт удалось значительно оптимизировать по памяти за счёт использования генератора вместо списка,
# а также за счёт исключения нескольких промежуточных структур данных (ip_list, ip_dict) и дополнительных конструкций
# благодаря классу Counter из модуля collections.
# Разница по скорости выполнения незначительна, но всё же и по этому параметру оптимизированный
# скрипт даёт лучшие показатели.
# (А ещё скрипт стал гораздо короче...)
