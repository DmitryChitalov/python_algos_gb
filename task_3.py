"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""


def resolve_1(storage):
    """
    Сложность: N + 3 + N + N*5 + N + 1 + N*(1 + N + 3) + 1 = N^2 + 11*N + 5 или O(N^2)
    """
    cnt = 0  # O(1)
    res = []  # O(1)
    val_par = list(storage.values())  # O(N)
    while cnt < 3 and len(val_par) != 0:  # O(3)
        max_el = max(val_par)  # O(N) ищем максимальный капитал из имеющихся
        for name, price in storage.items():  # O(N)
            if price == max_el:  # O(1) ищем имена компаний с максимальным капиталом
                res.append(name)  # O(1)
                cnt += 1  # O(1) увеличиваем счетчик компаний
            if cnt == 3:  # O(1) если нашли 3 компании
                break  # O(1)
        cp = val_par.copy()  # O(N)
        i, k = 0, 0  # O(1)
        while i < len(cp) - k:  # O(N) удаляем уже найденные компании из списка для дальнейшего поиска
            if val_par[i] == max_el:  # O(1)
                del val_par[i]  # O(N)
                i -= 1  # O(1)
                k += 1  # O(1)
            i += 1  # O(1)
    return res  # O(1)


def resolve_2(storage):
    """
    Сложность: 3*(N + N + N*(4 + 2) + 3*N) + 2 = 33*N + 3 или O(N)
    """
    cnt = 0  # O(1)
    res = []  # O(1)
    while cnt < 3 and len(storage) > 0:   # O(3)
        val_par = list(storage.values())  # O(N)
        max_el = max(val_par)             # O(N) ищем максимальный капитал из имеющихся
        for name, elem in storage.items():  # O(N)
            if elem == max_el and name not in res:  # O(4) ищем ранее не встречавшиеся компании с максимальным капиталом
                res.append(name)   # O(1)
                cnt += 1  # O(1)
        for name in res:  # O(3) удаляем из общего исписка найденные компании для дальнейшего поиска
            if name in storage:  # O(N)
                del storage[name]  # O(1)
    return res  # O(1)


print(resolve_1({"Komp 1": 500, "Komp 2": 300, "Комп 3": 60, "Komp 7": 800}))
print(resolve_2({"Komp 1": 500, "Komp 2": 300, "Комп 3": 60, "Komp 7": 800}))

"""
2 Вариант решения намного более оптимальный, так как он выполняется за линейное время, 
в то время как первый - за квадратичное. Также 1 вариант решения более громоздкий
"""

