import time
"""
Задание 1.

Реализуйте заполнение списка и словаря, сделайте замеры и сделайте выводы, обоснуйте результат.
Сделайте несколько операций с каждым из объектов, сделайте замеры и сделайте выводы, обоснуйте результат.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к двум своим функциям.
"""


#############################################################

'''
    Заполнение списка происходит очень быстро, не смотря на то что в примере приходится генерировать
    содержимое для этого списка.
    И добавляем мы содержимое с помощью цикла, сложность которого О(п) и плюс на саму вставку надо время.
    Но я думаю из за того, в данном примере я вставляю в конец списка, потому что словарь простая структура,
    он и работает так быстро. Ибо он хранит любые типы данных почти без разбору, а только* сохраняет порядок елементов. 
'''


def check_time_list1():     # вставка в конец списка
    startt = time.time()
    my_list = []
    for i in range(1, 10001):
        my_list.append(i)
    fintime = time.time()
    return print(fintime-startt)


'''
    Как видно, вставка тех же елементов только в начало списка, занимает куда больше времени.
    Это и ожидаемо, так как после каждой вставки приходится сменять индекс всех елементов
    И чем в эитоге больше елементов тем медленее будут наши вставки.
'''
def check_time_list2():      # вставка в начало спискка
    startt = time.time()
    my_list = []
    for i in range(1, 10001):
        my_list.insert(0, i)
    fintime = time.time()
    return print(fintime-startt)


# ========================================================

'''
    В словарь вставка с помощью update происходит медленее чем в список но быстрее чем в начало списка.
    Я думаю это связано с тем что не словарю приходится работать с ключами и при вставке их нужно как бы просто
    проверить ест ли они, а не обновлять индексы как с вставкой в начало списка.
    
'''
def check_time_dict1():     # Через update
    startt = time.time()
    my_list = {}
    for i in range(1, 10001):
        my_list.update({f'{i}': i})
    fintime = time.time()
    return print(fintime-startt)

'''
    Вставка елементов через присваивание чуть быстрее чем через update, думаю связано с тем, что мы просто "в тупую"
    вставляем новый ключ со значением, то есть просто пополняем хеш таблицу
    И словарь вроде не гарантирует сохранение порядка чередования елементов НО - в новых обовлениях есть места,
    где прямым текстом заявляется о том, что все таки уже гарантируют - не знаю как это влияет на скорость.
'''
def check_time_dict2():     # Через присваивание
    startt = time.time()
    my_list = {}
    for i in range(1, 10001):
        my_list[f'{i}'] = i
    fintime = time.time()
    return print(fintime-startt)


check_time_list1()

check_time_list2()

check_time_dict1()

check_time_dict2()
