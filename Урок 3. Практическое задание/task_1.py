"""
Задание 1.

Реализуйте заполнение списка и словаря, сделайте замеры и сделайте выводы, обоснуйте результат.
Сделайте несколько операций с каждым из объектов, сделайте замеры и сделайте выводы, обоснуйте результат.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к двум своим функциям.
"""
import time


def fill_lst(obj, n):
    for i in range(n):
        obj.append(i)


def eject_lst(obj, n):
    for i in range(n):
        obj.index(i)


def fill_dct(obj, n):
    for i in range(n):
        obj[i] = i


def eject_dct(obj, n):
    for i in range(n):
        obj.get(i)


lst = []
dct = {}


start_time = time.time()
fill_lst(lst, 100000)
print(time.time() - start_time)

start_time = time.time()
fill_dct(dct, 100000)
print(time.time() - start_time)

start_time = time.time()
eject_lst(lst, 100000)
print(time.time() - start_time)

start_time = time.time()
eject_dct(dct, 100000)
print(time.time() - start_time)

'''
Выводы:
1) Список заполняется быстрее, чем словарь, т.к. списку нет необходимости вычислять хеш*.
* - тем не менее, я немного в замешательстве, потому что в большинстве замеров заполнение словаря происходит все равно
быстрее, чем списка. Замеры производил при разных значениях n(от 100 000 до 10 000 000) - либо словарь быстрее, либо
примерно одинаково, иногда список быстрее - данные очень разнятся... Не понимаю, почему так происходит.
2) Работа со словарем(например, поиск элемента) происходит значительно быстрее, т.к. нет необходимости проходить
по всему ряду данных для поиска элемента. У словаря сложность данной операции является O(1) - константной,
в то время как у списка она является O(n) - линейной.
'''