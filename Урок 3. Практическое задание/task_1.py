"""
Задание 1.

Реализуйте заполнение списка и словаря, сделайте замеры и сделайте выводы, обоснуйте результат.
Сделайте несколько операций с каждым из объектов, сделайте замеры и сделайте выводы, обоснуйте результат.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к двум своим функциям.
"""
import time
import random


def time_mesure(fn):
    """ декоратор для замера времени выполнения функции"""
    def wrape(*args):
        st_time = time.time() # начало замера
        res = fn(*args)
        end_time = time.time()
        return res, ['время выполнения: ', end_time - st_time] # возврат значения фукнциии и времени в секундах
    return wrape

@time_mesure
def make_list(l_val = 1000):
    """ Создает массив случайных двухзначных целых чисел от 10 до 100"""
    return [random.randint(10,99) for i in range(l_val)]

@time_mesure
def make_dict(l_val = 1000):
    """ Создает словарь из случайных двухзначных целых чисел,
    в качестве ключа используется порядковый номер элемента"""
    data = dict()

    for i in range(l_val):
        data[i] = random.randint(10,99)
    
    return data


@time_mesure
def get_elem(lst_obj,id = 100):
    """ Возвращает указанный элемент из списка""" 
    return lst_obj[id]

@time_mesure
def get_value(d_obj, id = 100):
    """ Возвращает указанный элемент словаря """
    return d_obj[id]

@time_mesure
def pop_list(lst_obj,id = 100):
    """ Выбрасывает указанный элемент из списка """
    return lst_obj.pop(id)

def pop_dict(d_obj, id = 100):
    """ Выбрасывает указанный элемент из словаря"""
    return d_obj.pop(id)

# клиентская часть

if __name__ == '__main__':
    print('Создание списка: \n')
    lst, t1 = make_list(1000)
    #print('Список ', lst)
    print('Время выполнения ', t1[1])

    print('Создание словаря: \n')
    dct, t2 = make_dict(1000)
    #print('Словарь ', dct)
    print('Время выполнения ', t2[1])

    print('Разность времени ', t2[1]-t1[1])
    
    """ В моей среде выполнения разница в скорости создания составила 0.00026 секунды в пользу списка. При создании списка не требуется время на генерацию массива ключей (хешей ключей). """

    print("\n Вывод элемента \n")

    val1, t21 = get_elem(lst)

    print('Значение элемента ', val1)
    print("Время выполнения: ", t21[1])

    val2, t22 = get_elem(dct)

    print('Значение элемента ', val2)
    print("Время выполнения: ", t22[1])

    print("Разность времени ", t22[1] - t21[1]) 

    """ Выполнение операции вывода элемента у словаря получилось быстрее, разность составила 1,19209е-06 секунды. В словаре сопоставление пары ключ-значение выполняется быстрее. Тоже самое и с извлечением элемента """

    print("\n Извлечение элемента \n")

    val3, t31 = get_elem(lst)

    print('Значение элемента ', val3)
    print("Время выполнения: ", t31[1])

    val4, t32 = get_elem(dct)

    print('Значение элемента ', val4)
    print("Время выполнения: ", t32[1])

    print("Разность времени ", t32[1] - t31[1]) 