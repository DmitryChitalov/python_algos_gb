"""
Задание 1.

Реализуйте заполнение списка и словаря, сделайте замеры и сделайте выводы, обоснуйте результат.
Сделайте несколько операций с каждым из объектов, сделайте замеры и сделайте выводы, обоснуйте результат.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к двум своим функциям.
"""
from time import time
from random import randint


def dec_time(func):
    def dec(*args, **kwargs):
        start_time = time()
        m = func(*args, **kwargs)
        print(f'Время выполнения: {time() - start_time} секунд')
        return m
    return dec


@dec_time
def fill_list(n):
    lst = []
    for i in range(n):
        lst.append(i)
    return lst


@dec_time
def fill_dict(n):
    dct = {}
    for i in range(n):
        # dct[i] = i  # в таком случае заполняется по времени столько же, сколько и список. иногда быстрее
        dct.update({i: i})  # в таком случае больше по времени в ~3 раза
        # dct[str(i)] = i  # в таком случае больше по времени в ~5 раз
    return dct
# Вывод: на время влияет сам метод добавления. Происходит из-за того, что в отдельных методах (append, update)
# происходят какие-то дополнительные операции, на которые тоже тратится время.
# Если рассматривать присваивание по ключу (самый первый вариант), то скорее всего это операция реализована
# и оптимизирована на низком уровне интерпретатора, из-за чего работает быстрее.
# Приведение типа занимает тоже время, из-за чего работа очень сильно замедляется
# Думаю, наиболее валидно сравнивать append и update соответсвенно, как два метода добавления для списка и словаря
# Добавление в список происходит быстрее, так как не надо вычислять хэши от ключей


@dec_time
def motion_list(list_num, num):
    for elem in range(0, 1000):
        del list_num[randint(0, num-1)]



@dec_time
def motion_dict(dct_num, num):
    for elem in range(0, 1000):
        del dct_num[randint(0, num-1)]



'''
Попробовал различный вариации взятия элементов по ключу из словаря и списка. Какого-то супер-прироста не получил
в случае со словарем. Иногда чуть быстрее, иногда чуть медленнее, чем список. 
Индексы и ключи для извлечения генерил рандомно и задавал специально, чтобы в списке было сложнее найти.
Возможно, проблема в погрешности замеров time. Но в теории любые операции извлечения в словаре выполняются быстрее,
чем в списке из-а быстроты поиска по хэш-таблице.
Операция del для словаря выполнялась в ~1000 раз быстрее чем для списка, так как list - связная структура, 
а словарь - просто таблица 'ключ - значение' без каких-либо связей между элементами/
Операция copy для списка выполнялась быстрее, чем для словаря, 
так как в словаре нужно копировать помимо самих данных ключи и механизмы предотвращения коллизий ключей
'''


if __name__ == '__main__':
    print('fill list:')
    lst = fill_list(10000000)
    print('fill dict:')
    dct = fill_dict(10000000)
    print('op list:')
    motion_list(lst, 10000000)
    print('op dict:')
    motion_dict(dct, 10000000)
