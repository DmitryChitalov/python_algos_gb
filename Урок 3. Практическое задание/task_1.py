"""
Задание 1.

Реализуйте заполнение списка и словаря, сделайте замеры и сделайте выводы, обоснуйте результат.
Сделайте несколько операций с каждым из объектов, сделайте замеры и сделайте выводы, обоснуйте результат.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к двум своим функциям.
"""
import time


def my_decorator(func):
    def inside():
        start_time = time.time()
        func()
        end_time = time.time()
        proc_name = 'Заполнение словаря.' if func.__name__ == 'fill_dict' else 'Заполнение списка. '
        print(f'{proc_name} Время: {end_time - start_time} сек.')
    return inside


@my_decorator
def fill_dict():
    user_dict = {}
    for idx in range(10000):
        if not idx in user_dict: # Это условие я добавил.*
            user_dict[idx] = idx


@my_decorator
def fill_list():
    user_list = []
    for idx in range(10000):
        if not idx in user_list: # Это условие я добавил.*
            user_list.append(idx)


fill_dict()
fill_list()

"""
Сначала я реализовал функции, которые просто заполняли словарь и список элементами.
При выполнении программы я увидел следующие результаты:
    Заполнение словаря. Время: 0.0009789466857910156 сек.
    Заполнение списка.  Время: 0.0007622241973876953 сек.
Затем я провел тест несколько раз.
По результатам можно сказать, что заполнение словаря происходит на 25% медленнее, чем словаря.

Затем я добавил условие проверки элемента на присутствие в словаре/списке* и снова сделал несколько запусков.
Новые результаты координально отличаются от предыдущих:
    Заполнение словаря. Время: 0.0010499954223632812 сек.
    Заполнение списка.  Время: 0.5365397930145264000 сек.
Теперь заполнение словаря происходит в ~510 раз быстрее чем списка!
Результаты так изменились, т.к. я добавил условие, в котором просходит поиск по словарю/списку.
В Python средняя временная сложность поиска словарного слова - O (1), поскольку они реализованы как хеш-таблицы.
Временная сложность поиска в списке - это O (n) в среднем.
"""
